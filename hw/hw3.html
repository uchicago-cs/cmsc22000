
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Homework 3: Make &#8212; CMSC 22000 - Introduction to Software Development</title>

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/chiweb.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Homework 3 Rubric" href="hw3_rubric.html" />
    <link rel="prev" title="Homework 2 Rubric" href="hw2_rubric.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          CMSC 22000 - Introduction to Software Development</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              
              
            
            
            
<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Information <span class="caret"></span></a>
    <ul class="dropdown-menu">
        <li><a href="../syllabus.html">Syllabus</a></li>
        <li><a href="../calendar.html">Calendar</a></li>
        <li><a href="../code-of-conduct.html">Code of Conduct for Course Staff</a></li>
    </ul>
</li>
<li><a href="index.html">Homework</a></li>
<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Project <span class="caret"></span></a>
    <ul class="dropdown-menu">
        <li><a href="../project/index.html">Introduction</a></li>
        <li><a href="../project/chiventure.html">chiventure</a></li>
        <li><a href="../project/policies.html">Policies</a></li>
        <li><a href="../project/features.html">Features</a></li>
    </ul>
</li>
<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Resources <span class="caret"></span></a>
    <ul class="dropdown-menu">
        <li><a href="../resources/faq.html">CS 220 FAQs</a></li>
        <li><a href="../resources/tutorials/index.html">Tutorials</a></li>
        <li><a href="https://uchicago-cs.github.io/dev-guide/" target="_blank">UChicago CS Developer's Guide <i class="fa fa-external-link"></i></a></li>
        <li><a href="https://uchicago-cs.github.io/debugging-guide" target="_blank">The Debugging Guide <i class="fa fa-external-link"></i></a></li>
        <li><a href="../resources/other.html">Other Resources</a></li>
    </ul>
</li>

            
          </ul>

          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Homework 3: Make</a><ul>
<li><a class="reference internal" href="#project-team-exercise-design-warm-up-part-ii">Project Team Exercise: Design Warm-up (Part II)</a></li>
<li><a class="reference internal" href="#creating-your-homework-repository">Creating your homework repository</a></li>
<li><a class="reference internal" href="#writing-makefiles">Writing Makefiles</a><ul>
<li><a class="reference internal" href="#compiling-a-program-with-multiple-c-files">Compiling a program with multiple C files</a></li>
<li><a class="reference internal" href="#writing-a-basic-makefile">Writing a basic <code class="docutils literal notranslate"><span class="pre">Makefile</span></code></a></li>
<li><a class="reference internal" href="#make-rules">Make rules</a></li>
<li><a class="reference internal" href="#separating-the-compilation-and-linking-steps">Separating the compilation and linking steps</a></li>
<li><a class="reference internal" href="#phony-rules">Phony rules</a></li>
<li><a class="reference internal" href="#variables">Variables</a></li>
<li><a class="reference internal" href="#automatic-variables-and-patterns">Automatic Variables and Patterns</a></li>
</ul>
</li>
<li><a class="reference internal" href="#task-1-makefile-for-the-micro-editor">Task 1: Makefile for the micro editor</a></li>
<li><a class="reference internal" href="#building-a-library">Building a library</a></li>
<li><a class="reference internal" href="#task-2-the-libgraph-library">Task 2: The libgraph library</a></li>
<li><a class="reference internal" href="#cmake">CMake</a></li>
<li><a class="reference internal" href="#submitting-your-homework">Submitting your homework</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <div class="section" id="homework-3-make">
<h1>Homework 3: Make<a class="headerlink" href="#homework-3-make" title="Permalink to this headline">¶</a></h1>
<p><strong>Due:</strong> Wednesday, April 20st, 8pm CDT</p>
<p>In the class project, you will likely produce dozens of C files that
will ultimately produce a single executable. When dealing with multiple
source files, specially when there are dependencies between them, it is
common to use a <em>build system</em> instead of manually compiling and linking
all the files. In this homework, we’ll explore the ways a program can be
“built”–that is, the way that source code is turned into binary code so
that a computer can execute it. In some cases, “building” may refer to
compiling a single file, but usually it refers to the whole process of
linking and creating a project: which can include linking, compiling,
and running tests. We’ll look at testing in later homeworks, and for this homework
we’ll focus on the <code class="docutils literal notranslate"><span class="pre">make</span></code> command as a way to compile and build
projects.</p>
<p>Similar to Homework #1, this homework involves following some tutorial-style
instructions to familiarize yourself with <code class="docutils literal notranslate"><span class="pre">make</span></code>, and will also include
some exercises where you can apply what you’ve learned about <code class="docutils literal notranslate"><span class="pre">make</span></code>.</p>
<div class="section" id="project-team-exercise-design-warm-up-part-ii">
<h2>Project Team Exercise: Design Warm-up (Part II)<a class="headerlink" href="#project-team-exercise-design-warm-up-part-ii" title="Permalink to this headline">¶</a></h2>
<p>Along with this week’s homework, we are also assigning the second part of the
design warm-up exercise, which you can find <a class="reference external" href="../project/design.html">here</a>.
Please note that the second part of the design exercise is due at the same time as this homework.</p>
</div>
<div class="section" id="creating-your-homework-repository">
<h2>Creating your homework repository<a class="headerlink" href="#creating-your-homework-repository" title="Permalink to this headline">¶</a></h2>
<p>Like previous homeworks, we will provide you with an <em>invitation URL</em> that
will allow you to sign up for the homework assignment on GitHub, and which will
result in the creation of a repository called
<code class="docutils literal notranslate"><span class="pre">hw3-GITHUB_USERNAME</span></code> inside our <code class="docutils literal notranslate"><span class="pre">uchicago-cmsc22000-2022</span></code> organization
on GitHub. Like Homework #2, your repository will be seeded with some files
for the homework.</p>
</div>
<div class="section" id="writing-makefiles">
<h2>Writing Makefiles<a class="headerlink" href="#writing-makefiles" title="Permalink to this headline">¶</a></h2>
<p>Before we get to the actual tasks in this homework, you will work through
a tutorial-style explanation of Makefiles. This will involve editing
a Makefile in your repository; make sure to commit your changes as
you complete them, as we will be checking whether you followed the steps
described in this tutorial (it is ok if you don’t commit every single
change as you make it, but it should be apparent from your commit log
that you worked through these steps).</p>
<div class="section" id="compiling-a-program-with-multiple-c-files">
<h3>Compiling a program with multiple C files<a class="headerlink" href="#compiling-a-program-with-multiple-c-files" title="Permalink to this headline">¶</a></h3>
<p>In the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> directory, you will see the following files:</p>
<ul class="simple">
<li><p>Point module: <code class="docutils literal notranslate"><span class="pre">point.c</span></code> and <code class="docutils literal notranslate"><span class="pre">point.h</span></code></p></li>
<li><p>Polygon module: <code class="docutils literal notranslate"><span class="pre">polygon.c</span></code> and <code class="docutils literal notranslate"><span class="pre">polygon.h</span></code></p></li>
<li><p>Auxiliary files: <code class="docutils literal notranslate"><span class="pre">common.h</span></code> and <code class="docutils literal notranslate"><span class="pre">utils.h</span></code></p></li>
<li><p>Polygon Area program: <code class="docutils literal notranslate"><span class="pre">polygon-area.c</span></code></p></li>
</ul>
<p>Before proceeding, make sure you’re inside the <code class="docutils literal notranslate"><span class="pre">polygon-area/</span></code>
directory:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">cd</span> polygon-area
</pre></div>
</div>
<p>All the files, except <code class="docutils literal notranslate"><span class="pre">polygon-area.c</span></code>, are taken directly from
the <code class="docutils literal notranslate"><span class="pre">libgeometry</span></code> example from Homework #2. Later in this homework
we will explain why <code class="docutils literal notranslate"><span class="pre">libgeometry</span></code> has a more elaborate directory
structure but, for the purposes of this homework, it’ll be simpler
to start with all the files in the same directory.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">polygon-area.c</span></code> file contains a <code class="docutils literal notranslate"><span class="pre">main()</span></code> function that relies
on the point and polygon modules to compute the area of a polygon
(after asking the user to provide the points in the polygon).</p>
<p>Notice how we can’t compile the <code class="docutils literal notranslate"><span class="pre">polygon-area.c</span></code> file by itself:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gcc polygon-area.c -o polygon-area
/usr/bin/ld: /tmp/ccmgP8wg.o: in <span class="k">function</span> <span class="sb">`</span>main<span class="s1">&#39;:</span>
<span class="s1">polygon-area.c:(.text+0x21): undefined reference to `polygon_new&#39;</span>
/usr/bin/ld: polygon-area.c:<span class="o">(</span>.text+0x95<span class="o">)</span>: undefined reference to <span class="sb">`</span>polygon_add_xy<span class="s1">&#39;</span>
<span class="s1">/usr/bin/ld: polygon-area.c:(.text+0x10c): undefined reference to `polygon_area&#39;</span>
collect2: error: ld returned <span class="m">1</span> <span class="nb">exit</span> status
</pre></div>
</div>
<p>This results in a bunch of <em>linker errors</em> (not compiler errors). There is nothing wrong
with <code class="docutils literal notranslate"><span class="pre">polygon-area.c</span></code> itself, but it depends on functions like <code class="docutils literal notranslate"><span class="pre">polygon_area</span></code>,
which are defined in a different C file (<code class="docutils literal notranslate"><span class="pre">polygon.c</span></code>). We need to compile that
file, as well as <code class="docutils literal notranslate"><span class="pre">point.c</span></code> (which the polygon module depends on), to be able
to produce the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> executable.</p>
<p>The simplest way to accomplish this is to simply pass all those files to the compiler:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gcc point.c polygon.c polygon-area.c -o polygon-area -lm
</pre></div>
</div>
<p>Remember that, internally, this is divided into two separate steps:</p>
<ul class="simple">
<li><p>Compiling: The compiler will compile each C file into an object file.</p></li>
<li><p>Linking: The compiler will link together all those files together into a single executable
(<code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>). Here, we also link to the math library, since
the point module relies on a couple of functions from that library (if you try re-running
the above command without the <code class="docutils literal notranslate"><span class="pre">-lm</span></code> option, you will see linker errors that refer
to math functions).</p></li>
</ul>
<p>Because we’re making a single call to the compiler, it doesn’t actually save the
object files anywhere, but that step is still happening internally.</p>
<p>At this point, you can try running the program. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./polygon-area
Please enter a value for x: 0
Please enter a value for y: 0
Would you like to enter another point? (y/n) y
Please enter a value for x: 0
Please enter a value for y: 2
Would you like to enter another point? (y/n) y
Please enter a value for x: 2
Please enter a value for y: 2
Would you like to enter another point? (y/n) y
Please enter a value for x: 2
Please enter a value for y: 0
Would you like to enter another point? (y/n) n
The area is 4.00
</pre></div>
</div>
</div>
<div class="section" id="writing-a-basic-makefile">
<h3>Writing a basic <code class="docutils literal notranslate"><span class="pre">Makefile</span></code><a class="headerlink" href="#writing-a-basic-makefile" title="Permalink to this headline">¶</a></h3>
<p>At this point, compiling our program involves running the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gcc point.c polygon.c polygon-area.c -o polygon-area -lm
</pre></div>
</div>
<p>This involves writing a relatively long command (which will only get longer
if we need to add more C files) that always involves re-compiling
every C file from scratch (and then linking them together).
Instead, we can use <code class="docutils literal notranslate"><span class="pre">make</span></code> to not just automate the building
of the program, but also optimize it (by avoiding un-necessary
compilation steps).</p>
<p>To use <code class="docutils literal notranslate"><span class="pre">make</span></code>, we will need to create a file called <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>
that specifies what we want to build. A <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> is just a
regular text file, so you are welcome to use your editor of choice
to create and edit Makefiles.</p>
<p>Let’s start by creating this very simple <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">polygon-area</span><span class="o">:</span>
     gcc point.c polygon.c polygon-area.c -o polygon-area -lm
</pre></div>
</div>
<p>The above code specifies a single <strong>make rule</strong>, that basically
says “To produce the file <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> run the command <code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">point.c</span> <span class="pre">polygon.c</span> <span class="pre">...</span></code>”.</p>
<p>Before trying out our <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>, we’re going to remove the
<code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> executable we previously compiled manually:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ rm polygon-area
</pre></div>
</div>
<p>You can now run the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> by running the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make polygon-area
</pre></div>
</div>
<p>By calling <code class="docutils literal notranslate"><span class="pre">make</span></code> like this, we are telling <code class="docutils literal notranslate"><span class="pre">make</span></code> “I need you to produce file <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>”
<code class="docutils literal notranslate"><span class="pre">make</span></code> will check the list of rules (by default, it will always look at the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> in the
same directory you are running <code class="docutils literal notranslate"><span class="pre">make</span></code>) and, if it finds a matching rule, it will run it.
In this case, it will run the <code class="docutils literal notranslate"><span class="pre">gcc</span></code> command we specified in the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> rule:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make polygon-area
gcc point.c polygon.c polygon-area.c -o polygon-area -lm
</pre></div>
</div>
<p>If we run this again, we’ll get a different output:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make polygon-area
make: <span class="s1">&#39;polygon-area&#39;</span> is up to date.
</pre></div>
</div>
<p>This is because <code class="docutils literal notranslate"><span class="pre">make</span></code> will skip producing the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> file
if it already exists (later on, we’ll see how we can affect this behaviour,
since there will be situations where we <em>do</em> want <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> to be
compiled again, e.g., if we make a change to <code class="docutils literal notranslate"><span class="pre">point.c</span></code>).</p>
<p>You may notice that you can also just run <code class="docutils literal notranslate"><span class="pre">make</span></code> without any parameters
(notice how we first remove <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>, so we don’t get the “up to date”
message):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ rm polygon-area
$ make
gcc point.c polygon.c polygon-area.c -o polygon-area -lm
</pre></div>
</div>
<p>There is a reason why this works as well, and we’ll explain it later on but,
for now, we’ll stick to explicitly specifying our <em>build target</em> when calling
<code class="docutils literal notranslate"><span class="pre">make</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>Beware the curse of the tabs and the missing separators!</strong></p>
<p>If you get an error message like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Makefile</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span> <span class="o">***</span> <span class="n">missing</span> <span class="n">separator</span><span class="o">.</span>  <span class="n">Stop</span><span class="o">.</span>
</pre></div>
</div>
<p>This means there may have been an issue when copy-pasting from this page
to the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>. More specifically, Makefiles use <a class="reference external" href="https://en.wikipedia.org/wiki/Tab_key">tab
characters</a> to indent the
commands in a rule. This makes it challenging to edit Makefiles if you
have set up your editor to use spaces to indent your code. If you’re
getting the “missing separator error”, it’s likely that your editor
automatically converted the tab characters to spaces.</p>
<p>If that is the case, you can tell <code class="docutils literal notranslate"><span class="pre">make</span></code> to use spaces instead of tabs
by adding the following at the top of your Makefile:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">RECIPEPREFIX</span> <span class="o">+=</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="make-rules">
<h3>Make rules<a class="headerlink" href="#make-rules" title="Permalink to this headline">¶</a></h3>
<p>We’ve seen earlier that, assuming the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> file
doesn’t exist, running <code class="docutils literal notranslate"><span class="pre">make</span></code> will run the <code class="docutils literal notranslate"><span class="pre">gcc</span></code> command
to compile it, and subsequent calls to <code class="docutils literal notranslate"><span class="pre">make</span></code> will just tell
us that the file is “up to date”:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make polygon-area
gcc point.c polygon.c polygon-area.c -o polygon-area -lm
$ make polygon-area
make: <span class="s1">&#39;polygon-area&#39;</span> is up to date.
$ make polygon-area
make: <span class="s1">&#39;polygon-area&#39;</span> is up to date.
</pre></div>
</div>
<p>So, <code class="docutils literal notranslate"><span class="pre">make</span></code> is definitely saving us from having to remember the full
command we want to type, and will also ensure we’re not needlessly
re-compiling the file if it already exists.</p>
<p>However, what if we make a change to one of the C files? In that
situation, we <em>do</em> want <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> to be recompiled.
<code class="docutils literal notranslate"><span class="pre">make</span></code> can also help us here: we can tell <code class="docutils literal notranslate"><span class="pre">make</span></code> what files <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>
depends on, so it will re-build <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> if any of
those files change.</p>
<p>We can do this by adding a list of dependencies or <em>prerequisites</em>
after the colon in the rule:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">polygon-area</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span> <span class="n">polygon</span>.<span class="n">c</span> <span class="n">polygon</span>-<span class="n">area</span>.<span class="n">c</span>
     gcc point.c polygon.c polygon-area.c -o polygon-area -lm
</pre></div>
</div>
<p>Now, let’s run <code class="docutils literal notranslate"><span class="pre">make</span></code> again:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make polygon-area
make: <span class="s1">&#39;polygon-area&#39;</span> is up to date.
</pre></div>
</div>
<p>Given that we haven’t made any changes to <code class="docutils literal notranslate"><span class="pre">point.c</span></code>, <code class="docutils literal notranslate"><span class="pre">polygon.c</span></code>,
or <code class="docutils literal notranslate"><span class="pre">polygon-area.c</span></code> since the last time we produced the
<code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> executable, <code class="docutils literal notranslate"><span class="pre">make</span></code> can tell that there is
no need to re-build <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>.</p>
<p>Now, try editing <code class="docutils literal notranslate"><span class="pre">polygon-area.c</span></code> (any trivial edit is enough,
e.g., add a newline at the bottom of the file). If we run
<code class="docutils literal notranslate"><span class="pre">make</span></code> again, it will detect that one of the prerequisite
files has changed, and it will re-build <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make polygon-area
gcc point.c polygon.c polygon-area.c -o polygon-area -lm
</pre></div>
</div>
<p>In general, Make rules have the following structure:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">rule-name</span><span class="o">:</span> <span class="n">prerequisite</span>
    <span class="nb">command</span>
</pre></div>
</div>
<p>Rules can have any number of (or zero) prerequisites
(separated by spaces), and any number of (or zero) commands (separated
by newlines). It’s important to note that while <code class="docutils literal notranslate"><span class="pre">make</span></code> is probably
most often used with C programs, <code class="docutils literal notranslate"><span class="pre">make</span></code> is a generic tool supporting
arbitrary commands.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Building produces a number of binary files,
including object files, executables, and (as we’ll see later in this
homework) library files. These should <em>never</em> be added to your Git
repository! You’ll notice that there’s actually a <code class="docutils literal notranslate"><span class="pre">.gitignore</span></code> file in
the root of your repository with a list of files that Git should ignore
(so you won’t inadvertently add them to your repository). It is good
practice to have such a file in any repository you create, to make sure
you never add binary files to your repository.</p>
</div>
</div>
<div class="section" id="separating-the-compilation-and-linking-steps">
<h3>Separating the compilation and linking steps<a class="headerlink" href="#separating-the-compilation-and-linking-steps" title="Permalink to this headline">¶</a></h3>
<p>There is still an issue with our Makefile: any time any of the
pre-requisite files change, all the files are re-compiled from
scratch. So, in the example above, we only changed <code class="docutils literal notranslate"><span class="pre">polygon-area.c</span></code>,
but that resulted in running this command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gcc</span> <span class="n">point</span><span class="o">.</span><span class="n">c</span> <span class="n">polygon</span><span class="o">.</span><span class="n">c</span> <span class="n">polygon</span><span class="o">-</span><span class="n">area</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">polygon</span><span class="o">-</span><span class="n">area</span> <span class="o">-</span><span class="n">lm</span>
</pre></div>
</div>
<p>Which tells <code class="docutils literal notranslate"><span class="pre">gcc</span></code> to compile all three files.</p>
<p>Ideally, if we only modified <code class="docutils literal notranslate"><span class="pre">polygon-area.c</span></code>, we would like to only
re-compile that file. However, to do this, we have to separately
produce the object files for each of the C files. From the command-line,
we would do so like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gcc point.c -c -o point.o
$ gcc polygon.c -c -o polygon.o
$ gcc polygon-area.c -c -o polygon-area.o
</pre></div>
</div>
<p>Notice how we use the <code class="docutils literal notranslate"><span class="pre">-c</span></code> parameter to the compiler: this tells
the compiler to only compile the specified file, and to not attempt
to link it. This produces an <em>object</em> file with the compiled version
of the code in that C file (and that C file alone).</p>
<p>To link those object files together, we call the compiler like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gcc point.o polygon.o polygon-area.o -o polygon-area -lm
</pre></div>
</div>
<p>Notice how we’re not passing any C files to the compiler: by passing
only object files, <code class="docutils literal notranslate"><span class="pre">gcc</span></code> knows that no further compilation is required,
and that all it has to do is to link them together (and with the math
library, specified with the <code class="docutils literal notranslate"><span class="pre">-lm</span></code> parameter).</p>
<div class="admonition-what-happens-if-we-omit-the-c-option admonition">
<p class="admonition-title">What happens if we omit the <code class="docutils literal notranslate"><span class="pre">-c</span></code> option?</p>
<p>Let’s see what happens if we omit the <code class="docutils literal notranslate"><span class="pre">-c</span></code> option when
compiling the object files:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gcc polygon.c -o polygon.o
/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o: in <span class="k">function</span> <span class="sb">`</span>_start<span class="s1">&#39;:</span>
<span class="s1">(.text+0x24): undefined reference to `main&#39;</span>
/usr/bin/ld: /tmp/cc5mU0L8.o: in <span class="k">function</span> <span class="sb">`</span>polygon_add_xy<span class="s1">&#39;:</span>
<span class="s1">polygon.c:(.text+0x212): undefined reference to `point_init&#39;</span>
/usr/bin/ld: /tmp/cc5mU0L8.o: in <span class="k">function</span> <span class="sb">`</span>polygon_add_point<span class="s1">&#39;:</span>
<span class="s1">polygon.c:(.text+0x3e5): undefined reference to `segment_intersect&#39;</span>
/usr/bin/ld: /tmp/cc5mU0L8.o: in <span class="k">function</span> <span class="sb">`</span>polygon_perimeter<span class="s1">&#39;:</span>
<span class="s1">polygon.c:(.text+0x64f): undefined reference to `point_distance&#39;</span>
collect2: error: ld returned <span class="m">1</span> <span class="nb">exit</span> status
</pre></div>
</div>
<p>If we run the compiler like this, it will perform both a compilation and linking
step. This means that, since <code class="docutils literal notranslate"><span class="pre">polygon.c</span></code> includes calls to function like
<code class="docutils literal notranslate"><span class="pre">point_init</span></code> and <code class="docutils literal notranslate"><span class="pre">segment_intersect</span></code>, it will attempt to link those calls
to their implementation (but that implementation is nowhere to be found in <code class="docutils literal notranslate"><span class="pre">polygon.c</span></code>).
If we only perform the compilation step (by using the <code class="docutils literal notranslate"><span class="pre">-c</span></code> option) those calls
are left unlinked in the object file, so they don’t cause any errors.</p>
<p>Notice how we also get this error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(.text+0x24): undefined reference to `main&#39;
</pre></div>
</div>
<p>This is because, by default, the compiler will try to produce an executable file,
which means it will look for a <code class="docutils literal notranslate"><span class="pre">main()</span></code> function that specifies what that
executable will do (and will produce a linker error if no such function is found)</p>
</div>
<p>Now that we’ve separated the compiling and linking steps, we can avoid
re-compiling all the C files every time. For example, if we modify only
the <code class="docutils literal notranslate"><span class="pre">point.c</span></code> file, producing an updated <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> executable
would just require running the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gcc point.c -c -o point.o
$ gcc point.o polygon.o polygon-area.o -o polygon-area -lm
</pre></div>
</div>
<p>To automate this with <code class="docutils literal notranslate"><span class="pre">make</span></code>, we need to specify separate
rules for the object files. For example, this is what the rule
for producing the <code class="docutils literal notranslate"><span class="pre">point.o</span></code> object file would look like.</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">point.o</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span>
    gcc point.c -c -o point.o
</pre></div>
</div>
<p>Remember that this is basically saying “To produce file <code class="docutils literal notranslate"><span class="pre">point.o</span></code>, run
<code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">point.c</span> <span class="pre">...</span></code>, but only if <code class="docutils literal notranslate"><span class="pre">point.c</span></code> has changed since the last
time we built <code class="docutils literal notranslate"><span class="pre">point.o</span></code>”.</p>
<p>Our full <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> would now look like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">point.o</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span>
    gcc point.c -c -o point.o

<span class="nf">polygon.o</span><span class="o">:</span> <span class="n">polygon</span>.<span class="n">c</span>
    gcc polygon.c -c -o polygon.o

<span class="nf">polygon-area.o</span><span class="o">:</span> <span class="n">polygon</span>-<span class="n">area</span>.<span class="n">c</span>
    gcc polygon-area.c -c -o polygon-area.o

<span class="nf">polygon-area</span><span class="o">:</span> <span class="n">point</span>.<span class="n">o</span> <span class="n">polygon</span>.<span class="n">o</span> <span class="n">polygon</span>-<span class="n">area</span>.<span class="n">o</span>
    gcc point.o polygon.o polygon-area.o -o polygon-area -lm
</pre></div>
</div>
<p>Notice how the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> rule now depends on the object files,
not on the C files.</p>
<p>Let’s give this a try, but lets first make sure that we’re starting
from scratch. Run the following to delete any files we may have built:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ rm -f point.o polygon.o polygon-area.o polygon-area
</pre></div>
</div>
<p>Now, let’s run <code class="docutils literal notranslate"><span class="pre">make</span></code>:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make polygon-area
gcc point.c -c -o point.o
gcc polygon.c -c -o polygon.o
gcc polygon-area.c -c -o polygon-area.o
gcc point.o polygon.o polygon-area.o -o polygon-area -lm
</pre></div>
</div>
<p>Notice how <code class="docutils literal notranslate"><span class="pre">make</span></code> was able to sort out all the dependencies, and figure out
that, to produce <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>, it first needed to produce the object files
listed in its prerequisites.</p>
<p>If we try to run <code class="docutils literal notranslate"><span class="pre">make</span></code> again, it will correctly realize that nothing has
changed, and that we don’t need to re-build anything:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make polygon-area
make: <span class="s1">&#39;polygon-area&#39;</span> is up to date.
</pre></div>
</div>
<p>Now, let’s see what happens if we edit one of the files except, instead of
editing the file, we will use the <code class="docutils literal notranslate"><span class="pre">touch</span></code> command:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ touch polygon.c
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">touch</span></code> command is a handy command that will simply update the
“last modified” date on a file, without actually changing its contents.
(that timestamp is actually what <code class="docutils literal notranslate"><span class="pre">make</span></code> is looking at when determining
whether a file has changed since the last time it was compiled).</p>
<p>If we run <code class="docutils literal notranslate"><span class="pre">make</span></code> again, we’ll see that it correctly figures out that
it only needs to re-build the <code class="docutils literal notranslate"><span class="pre">polygon.o</span></code> file, and then re-link it
with the existing object files:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make polygon-area
gcc polygon.c -c -o polygon.o
gcc point.o polygon.o polygon-area.o -o polygon-area -lm
</pre></div>
</div>
</div>
<div class="section" id="phony-rules">
<h3>Phony rules<a class="headerlink" href="#phony-rules" title="Permalink to this headline">¶</a></h3>
<p>So far, we’ve defined a couple of rules whose goal is to
produce specific files (either the object files or the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>
executable). However, it is also possible to write so-called
<em>phony</em> rules that don’t produce any files, and which instead just perform
some action.</p>
<p>For example, we’ve previously run the following command
to delete all the generated files:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ rm -f point.o polygon.o polygon-area.o polygon-area
</pre></div>
</div>
<p>We can create a <code class="docutils literal notranslate"><span class="pre">clean</span></code> rule that performs this action:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">clean</span><span class="o">:</span>
    rm -f point.o polygon.o polygon-area.o polygon-area
</pre></div>
</div>
<p>And which we can run like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make clean
rm -f point.o polygon.o polygon-area.o polygon-area
</pre></div>
</div>
<p>However, notice how running the <code class="docutils literal notranslate"><span class="pre">rm</span></code> command doesn’t
produce a file called <code class="docutils literal notranslate"><span class="pre">clean</span></code> (like our previous rules did,
where the effect of the rule’s command was to generate a file
matching the target of the rule).</p>
<p>So, while the rule will work as-is, we will want to label it
as a “phony” rule, by adding this to our <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">.PHONY</span><span class="o">:</span> <span class="n">clean</span>
</pre></div>
</div>
<p>This lets <code class="docutils literal notranslate"><span class="pre">make</span></code> know that it should not expect the <code class="docutils literal notranslate"><span class="pre">clean</span></code>
rule to actually produce a file called <code class="docutils literal notranslate"><span class="pre">clean</span></code>. This means that,
in the unlikely event that we actually need to create a file called
<code class="docutils literal notranslate"><span class="pre">clean</span></code> for some other purpose, <code class="docutils literal notranslate"><span class="pre">make</span></code> won’t take that file
into account when deciding to run the <code class="docutils literal notranslate"><span class="pre">clean</span></code> rule.</p>
<p>In general, it is good practice to always include a <code class="docutils literal notranslate"><span class="pre">clean</span></code> rule
in your <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>, specifying how to “clean up” all the files
generated by the compiler.</p>
<p>Before we see another common phony rule, try running <code class="docutils literal notranslate"><span class="pre">make</span></code> without
any parameters (make sure you’ve run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">clean</span></code> as shown above before
doing this):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make
gcc point.c -c -o point.o
</pre></div>
</div>
<p>This seems wrong: if I run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">clean</span></code> and then run <code class="docutils literal notranslate"><span class="pre">make</span></code> again,
I would expect <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> to be built again, instead of just
the <code class="docutils literal notranslate"><span class="pre">point.o</span></code> object file. The reason this is happening is that
<em>if you run make without any parameters, it will run the first rule
in the file</em> (which, in our case, happens to be rule for building
the <code class="docutils literal notranslate"><span class="pre">point.o</span></code> file).</p>
<p>While we could move the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> rule to the top of the file,
a more common practice is to create a phony <code class="docutils literal notranslate"><span class="pre">all</span></code> rule that specifies
what the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> should build, and which appears before all other
rules.</p>
<p>In our case, this rule would look like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">all</span><span class="o">:</span> <span class="n">polygon</span>-<span class="n">area</span>
</pre></div>
</div>
<p>And let’s make sure we add it to the list of phony rules:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">.PHONY</span><span class="o">:</span> <span class="n">clean</span> <span class="n">all</span>
</pre></div>
</div>
<p>To recap, our full Makefile should now look like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">all</span><span class="o">:</span> <span class="n">polygon</span>-<span class="n">area</span>

<span class="nf">.PHONY</span><span class="o">:</span> <span class="n">clean</span> <span class="n">all</span>

<span class="nf">point.o</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span>
    gcc point.c -c -o point.o

<span class="nf">polygon.o</span><span class="o">:</span> <span class="n">polygon</span>.<span class="n">c</span>
    gcc polygon.c -c -o polygon.o

<span class="nf">polygon-area.o</span><span class="o">:</span> <span class="n">polygon</span>-<span class="n">area</span>.<span class="n">c</span>
    gcc polygon-area.c -c -o polygon-area.o

<span class="nf">polygon-area</span><span class="o">:</span> <span class="n">point</span>.<span class="n">o</span> <span class="n">polygon</span>.<span class="n">o</span> <span class="n">polygon</span>-<span class="n">area</span>.<span class="n">o</span>
    gcc point.o polygon.o polygon-area.o -o polygon-area -lm

<span class="nf">clean</span><span class="o">:</span>
    rm -f point.o polygon.o polygon-area.o polygon-area
</pre></div>
</div>
<p>Let’s try running <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">clean</span></code> followed by <code class="docutils literal notranslate"><span class="pre">make</span></code>:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make clean
rm -f point.o polygon.o polygon-area.o polygon-area
$ make
gcc point.c -c -o point.o
gcc polygon.c -c -o polygon.o
gcc polygon-area.c -c -o polygon-area.o
gcc point.o polygon.o polygon-area.o -o polygon-area -lm
</pre></div>
</div>
<p>Now, when we call <code class="docutils literal notranslate"><span class="pre">make</span></code> (without any parameters), Make will try to build
the first rule in the file. That rule is the <code class="docutils literal notranslate"><span class="pre">all</span></code> rule, which has one
prerequisite, <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>, so it will perform the steps needed to
build that file.</p>
</div>
<div class="section" id="variables">
<h3>Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h3>
<p>Besides defining rules, Make also allows us to define variables,
which can help keep our Makefile tidy. Two variables you’ll
often see in Makefiles are <code class="docutils literal notranslate"><span class="pre">CC</span></code>, to specify the compiler
we want to use, and <code class="docutils literal notranslate"><span class="pre">CFLAGS</span></code>, to specify the parameters
we want to pass to the compiler.</p>
<p>For example, let’s add this at the top of our <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">CC</span> <span class="o">=</span> clang
<span class="nv">CFLAGS</span> <span class="o">=</span> -g -O2 -Wall -Wextra
</pre></div>
</div>
<p>To use a variable, we just write it’s name between <code class="docutils literal notranslate"><span class="pre">$(</span></code> and <code class="docutils literal notranslate"><span class="pre">)</span></code>.
For example, our previous rule for the <code class="docutils literal notranslate"><span class="pre">point.o</span></code> file:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">point.o</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span>
    gcc point.c -c -o point.o
</pre></div>
</div>
<p>Will now look like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">point.o</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> point.c -c -o point.o
</pre></div>
</div>
<p>Notice how this is not a direct translation of the previous rule:
we’ve generalized it so that we can use whatever compiler is
specified the <code class="docutils literal notranslate"><span class="pre">CC</span></code> variable (which is different from the
one we were previously using), and are now able to easily
specify additional compiler options in the <code class="docutils literal notranslate"><span class="pre">CFLAGS</span></code> variable
(we didn’t include these options in our previous rules to keep
them simple). The options we’ve included are common options that
enable debugging symbols (<code class="docutils literal notranslate"><span class="pre">-g</span></code>, we’ll learn more about this
in the next homework), enable optimizations (<code class="docutils literal notranslate"><span class="pre">-O2</span></code>), and tells
the compiler to enable more warning messages (<code class="docutils literal notranslate"><span class="pre">-Wall</span> <span class="pre">-Wextra</span></code>).</p>
<p>Next, when writing a Makefile that compiles multiple object files
and then links them together, it is common to have an <code class="docutils literal notranslate"><span class="pre">OBJS</span></code> variable
to specify the list of object files, and a <code class="docutils literal notranslate"><span class="pre">BIN</span></code> variable to
specify the executable we are generating (an executable is sometimes
referred to as a “binary”). It is also common to define a
<code class="docutils literal notranslate"><span class="pre">LDLIBS</span></code> variable to specify any additional libraries we
are going to link with.</p>
<p>So, let’s add this at the top of our Makefile:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">LDLIBS</span> <span class="o">=</span> -lm
<span class="nv">OBJS</span> <span class="o">=</span> point.o polygon.o polygon-area.o
<span class="nv">BIN</span> <span class="o">=</span> polygon-area
</pre></div>
</div>
<p>Then, this rule:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">polygon-area</span><span class="o">:</span> <span class="n">point</span>.<span class="n">o</span> <span class="n">polygon</span>.<span class="n">o</span> <span class="n">polygon</span>-<span class="n">area</span>.<span class="n">o</span>
    gcc point.o polygon.o polygon-area.o -o polygon-area -lm
</pre></div>
</div>
<p>Would become this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">$(BIN)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJS</span><span class="k">)</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>OBJS<span class="k">)</span> -o <span class="k">$(</span>BIN<span class="k">)</span> <span class="k">$(</span>LDLIBS<span class="k">)</span>
</pre></div>
</div>
<p>After updating all the rules, our Makefile would look like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">CC</span> <span class="o">=</span> clang
<span class="nv">CFLAGS</span> <span class="o">=</span> -g -O2 -Wall -Wextra
<span class="nv">LDLIBS</span> <span class="o">=</span> -lm

<span class="nv">OBJS</span> <span class="o">=</span> point.o polygon.o polygon-area.o
<span class="nv">BIN</span> <span class="o">=</span> polygon-area

<span class="nf">all</span><span class="o">:</span> <span class="k">$(</span><span class="nv">BIN</span><span class="k">)</span>

<span class="nf">.PHONY</span><span class="o">:</span> <span class="n">clean</span> <span class="n">all</span>

<span class="nf">point.o</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> point.c -c -o point.o

<span class="nf">polygon.o</span><span class="o">:</span> <span class="n">polygon</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> polygon.c -c -o polygon.o

<span class="nf">polygon-area.o</span><span class="o">:</span> <span class="n">polygon</span>-<span class="n">area</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> polygon-area.c -c -o polygon-area.o

<span class="nf">$(BIN)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJS</span><span class="k">)</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>OBJS<span class="k">)</span> -o <span class="k">$(</span>BIN<span class="k">)</span> <span class="k">$(</span>LDLIBS<span class="k">)</span>

<span class="nf">clean</span><span class="o">:</span>
    rm -f <span class="k">$(</span>OBJS<span class="k">)</span> <span class="k">$(</span>BIN<span class="k">)</span>
</pre></div>
</div>
<p>Notice how this makes it much easier for us to update something like the
compiler flags, or the name of the executable we are generating, without
having to muck around with the rules themselves. All that would be required
would be to update the variables at the top of the file.</p>
<p>Before moving on, let’s make sure this works as expected:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make clean
rm point.o polygon.o polygon-area.o polygon-area
$ make
clang -g -O2 -Wall -Wextra point.c -c -o point.o
clang -g -O2 -Wall -Wextra polygon.c -c -o polygon.o
clang -g -O2 -Wall -Wextra polygon-area.c -c -o polygon-area.o
clang point.o polygon.o polygon-area.o -o polygon-area -lm
</pre></div>
</div>
<p>Notice how <code class="docutils literal notranslate"><span class="pre">make</span></code> is now using <code class="docutils literal notranslate"><span class="pre">clang</span></code> as the compiler, and is including
the specified compiler parameters when compiling the object files.</p>
</div>
<div class="section" id="automatic-variables-and-patterns">
<h3>Automatic Variables and Patterns<a class="headerlink" href="#automatic-variables-and-patterns" title="Permalink to this headline">¶</a></h3>
<p>Our Makefile is looking pretty good, but notice how the following
rules all follow the same pattern: an object file that depends on a
C file, where the command to build the object file is identical
across all the rules (except for the files involved).</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">point.o</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> point.c -c -o point.o

<span class="nf">polygon.o</span><span class="o">:</span> <span class="n">polygon</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> polygon.c -c -o polygon.o

<span class="nf">polygon-area.o</span><span class="o">:</span> <span class="n">polygon</span>-<span class="n">area</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> polygon-area.c -c -o polygon-area.o
</pre></div>
</div>
<p>Fortunately, Make provides a number of mechanism that can allow us
to build more general rules, instead of having to write a single
rule per object file.</p>
<p>First, we have <em>automatic variables</em> that allow us to access
information about a rule. The ones we’ll need to use are the
following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> refers to the target of the rule</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$^</span></code> is the names of all the prerequisites, separated by spaces</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$&lt;</span></code> is the name of the first prerequisite</p></li>
</ul>
<p>So, for example, it would be possible to rewrite this rule:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">point.o</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> point.c -c -o point.o
</pre></div>
</div>
<p>Like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">point.o</span><span class="o">:</span> <span class="n">point</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> $&lt; -c -o <span class="nv">$@</span>
</pre></div>
</div>
<p>This makes the rule a bit less error-prone, as it ensures that we’re using the
correct values in the command, but we would still need to write a separate
rule for each object file.</p>
<p>To write a single general rule for all the object files, we will need to use
<em>patterns</em>. For example, we could write a pattern rule like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">%.o</span><span class="o">:</span> %.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> $&lt; -c -o <span class="nv">$@</span>
</pre></div>
</div>
<p>In this rule, <code class="docutils literal notranslate"><span class="pre">%.o</span></code> will match any file ending with <code class="docutils literal notranslate"><span class="pre">.o</span></code>, and will
set its prerequisite to the same file, but replacing <code class="docutils literal notranslate"><span class="pre">.o</span></code> with <code class="docutils literal notranslate"><span class="pre">.c</span></code>.</p>
<p>While this can be a useful rule, it is a bit too broad for our purposes,
since we have a specific list of object files we want to compile. We can
instead write the rule like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">$(OBJS)</span><span class="o">:</span> %.<span class="n">o</span>:%.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> $&lt; -c -o <span class="nv">$@</span>
</pre></div>
</div>
<p>This has the same effect as the previous (more general) rule, but
limiting the list of targets only to the files in the <code class="docutils literal notranslate"><span class="pre">OBJS</span></code> variable.</p>
<p>It is also possible to peform pattern substitutions on variables.
For example, we could redefine our <code class="docutils literal notranslate"><span class="pre">OBJS</span></code> variable like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">SRCS</span> <span class="o">=</span> point.c polygon.c polygon-area.c
<span class="nv">OBJS</span> <span class="o">=</span> <span class="k">$(</span>SRCS:.c<span class="o">=</span>.o<span class="k">)</span>
</pre></div>
</div>
<p>We first define a <code class="docutils literal notranslate"><span class="pre">SRCS</span></code> variable with our source files,
and then define <code class="docutils literal notranslate"><span class="pre">OBJS</span></code> to be <code class="docutils literal notranslate"><span class="pre">$(SRCS:.c=.o)</span></code>, which just means
“take the <code class="docutils literal notranslate"><span class="pre">SRCS</span></code> variable, and substitute the <code class="docutils literal notranslate"><span class="pre">.c</span></code> extension for <code class="docutils literal notranslate"><span class="pre">.o</span></code>
in all files”.</p>
<p>To recap, our Makefile should now look like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">CC</span> <span class="o">=</span> clang
<span class="nv">CFLAGS</span> <span class="o">=</span> -g -O2 -Wall -Wextra
<span class="nv">LDLIBS</span> <span class="o">=</span> -lm

<span class="nv">SRCS</span> <span class="o">=</span> point.c polygon.c polygon-area.c
<span class="nv">OBJS</span> <span class="o">=</span> <span class="k">$(</span>SRCS:.c<span class="o">=</span>.o<span class="k">)</span>
<span class="nv">BIN</span> <span class="o">=</span> polygon-area

<span class="nf">all</span><span class="o">:</span> <span class="k">$(</span><span class="nv">BIN</span><span class="k">)</span>

<span class="nf">.PHONY</span><span class="o">:</span> <span class="n">clean</span> <span class="n">all</span>

<span class="nf">$(OBJS)</span><span class="o">:</span> %.<span class="n">o</span>:%.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> $&lt; -c -o <span class="nv">$@</span>

<span class="nf">$(BIN)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJS</span><span class="k">)</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>OBJS<span class="k">)</span> -o <span class="k">$(</span>BIN<span class="k">)</span> <span class="k">$(</span>LDLIBS<span class="k">)</span>

<span class="nf">clean</span><span class="o">:</span>
    rm -f <span class="k">$(</span>OBJS<span class="k">)</span> <span class="k">$(</span>BIN<span class="k">)</span>
</pre></div>
</div>
<p>Let’s make sure it works correctly:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make clean
rm -f point.o polygon.o polygon-area.o polygon-area
$ make
clang -g -O2 -Wall -Wextra -c -o point.o point.c
clang -g -O2 -Wall -Wextra -c -o polygon.o polygon.c
clang -g -O2 -Wall -Wextra -c -o polygon-area.o polygon-area.c
clang point.o polygon.o polygon-area.o -o polygon-area -lm
</pre></div>
</div>
</div>
</div>
<div class="section" id="task-1-makefile-for-the-micro-editor">
<h2>Task 1: Makefile for the micro editor<a class="headerlink" href="#task-1-makefile-for-the-micro-editor" title="Permalink to this headline">¶</a></h2>
<p>We have included a <code class="docutils literal notranslate"><span class="pre">micro-editor</span></code> directory in your repository with
the code for a very simple terminal-based editor
called <code class="docutils literal notranslate"><span class="pre">micro</span></code>. This is our version of the <code class="docutils literal notranslate"><span class="pre">kilo</span></code> editor, a simple
but functional text editor that can be implemented in about 1,000 lines of C
code; if you’re interested, you can see a step-by-step guide to writing this
editor here: <a class="reference external" href="https://viewsourcecode.org/snaptoken/kilo/">https://viewsourcecode.org/snaptoken/kilo/</a> (please note that you
do not have to read this to complete this homework; however, if you’re interested
in the inner workings of a text editor, you may find that guide interesting).</p>
<p><code class="docutils literal notranslate"><span class="pre">micro</span></code> largely follows the same structure as the <code class="docutils literal notranslate"><span class="pre">kilo</span></code> code, except we
divided it into multiple modules and documented the code following our style guide.</p>
<p>You can compile and run the editor like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gcc src/*.c -o micro
$ ./micro
</pre></div>
</div>
<p>This will open the editor with a “blank file”. You can start typing to edit
the file, and you’ll notice that you can move around with the arrow keys, use
the Backspace key, and the Delete key. You should be able to quit the editor
by pressing Ctrl-Q (if you modified the file, you’ll have to press it three
times to confirm you want to exit without saving).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you run <code class="docutils literal notranslate"><span class="pre">micro</span></code> inside a code editor’s terminal (e.g., inside Visual
Studio Code’s terminal), make sure that you click on the terminal
before pressing Ctrl-Q, to ensure the Ctrl-Q is processed by the terminal
and not by the editor (which might use Ctrl-Q for something different)</p>
</div>
<p>Your task is simple: write a Makefile that will build the <code class="docutils literal notranslate"><span class="pre">micro</span></code>
executable. Take into account that, while we were able to compile
the executable just by running <code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">src/*.c</span> <span class="pre">-o</span> <span class="pre">micro</span></code>, your Makefile
should follow the same approach as the Makefile for <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>:
you must build each object file separately, and link them together
into a <code class="docutils literal notranslate"><span class="pre">micro</span></code> executable. You must also use variables and patterns
to avoid repeated code in your Makefile.</p>
<div class="admonition-the-cmakelists-txt-file admonition">
<p class="admonition-title">The <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> file</p>
<p>You’ll notice there is also a <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> file in the
<code class="docutils literal notranslate"><span class="pre">micro-editor</span></code> directory. You can ignore that file for now;
we will come back to it later in the homework.</p>
</div>
</div>
<div class="section" id="building-a-library">
<h2>Building a library<a class="headerlink" href="#building-a-library" title="Permalink to this headline">¶</a></h2>
<p>For this part of the homework, we will return to the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>
example. Make sure you are in that directory, and not the <code class="docutils literal notranslate"><span class="pre">micro-editor</span></code>
directory.</p>
<p>So far, we’ve written a Makefile whose ultimate purpose is to build
a <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> executable. However, let’s say that we now
wanted to build an additional executable, <code class="docutils literal notranslate"><span class="pre">point-distance</span></code>, that
relied on the Point module. Go ahead and create a file called
<code class="docutils literal notranslate"><span class="pre">point-distance.c</span></code> with the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;point.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">point_t</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[Point 1] Please enter a value for x: &quot;</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[Point 1] Please enter a value for y: &quot;</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[Point 2] Please enter a value for x: &quot;</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[Point 2] Please enter a value for y: &quot;</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The distance between (%.2lf, %.2lf) and &quot;</span>
           <span class="s">&quot;(%.2lf, %.2lf) is %.2lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>
           <span class="n">point_distance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Make sure to add/commit/push this file to your repository.</p>
<p>We <em>could</em> create another Makefile where the <code class="docutils literal notranslate"><span class="pre">BIN</span></code> variable is set
to <code class="docutils literal notranslate"><span class="pre">point-distance</span></code>, or we could even edit our existing Makefile
with an additional rule to build <code class="docutils literal notranslate"><span class="pre">point-distance</span></code>. However,
this would result in <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> and <code class="docutils literal notranslate"><span class="pre">point-distance</span></code>
being <em>statically linked</em> with the Point and Polygon modules,
meaning that the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> and <code class="docutils literal notranslate"><span class="pre">point-distance</span></code> executables
will contain the compiled binary code for any Point or Polygon functions they
use. If we have a lot of executables like this, that could mean
a lot of repeated binary code across all the executables.</p>
<p>Instead, it would be preferable to build the Point and Polygon modules
into a <em>shared library</em> that can be <em>dynamically linked</em> with the
<code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> and <code class="docutils literal notranslate"><span class="pre">point-distance</span></code> executables. More specifically,
we will build a <code class="docutils literal notranslate"><span class="pre">libgeometry.so</span></code> file containing the binary code
of the Point and Polygon modules.</p>
<p>For example, the compiled binary code for the <code class="docutils literal notranslate"><span class="pre">point_distance</span></code>
function would be contained in <code class="docutils literal notranslate"><span class="pre">libgeometry.so</span></code>, and the <code class="docutils literal notranslate"><span class="pre">point-distance</span></code>
executable would just include a reference to that function
(that would be linked to the actual <code class="docutils literal notranslate"><span class="pre">point_distance</span></code> code in <code class="docutils literal notranslate"><span class="pre">libgeometry.so</span></code>
when the <code class="docutils literal notranslate"><span class="pre">point-distance</span></code> executable is run).</p>
<p>To build the library, we would just need to run this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ gcc -fPIC -c point.c -o point.o
$ gcc -fPIC -c polygon.c -o polygon.o
$ gcc -shared -o libgeometry.so point.o polygon.o
</pre></div>
</div>
<p>Notice how we’re compiling the Point and Polygon modules as we did
before, but we are now using the <code class="docutils literal notranslate"><span class="pre">-fPIC</span></code> option. This flag tells
gcc to enable <em>position-independent code</em>. Position-independence
is beyond the scope of this homework, but it’s necessary for
building shared libraries.</p>
<p>Then, we simply link the <code class="docutils literal notranslate"><span class="pre">point.o</span></code> and <code class="docutils literal notranslate"><span class="pre">polygon.o</span></code> object files
like we did before except, instead of producing an executable,
we produce the <code class="docutils literal notranslate"><span class="pre">libgeometry.so</span></code> file (the <code class="docutils literal notranslate"><span class="pre">-shared</span></code> option
instructs the linker to produce a library instead of an executable).</p>
<p>Then, to build the <code class="docutils literal notranslate"><span class="pre">point-distance</span></code> executable, we do the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>gcc point-distance.c -o point-distance -L. -lgeometry -lm
</pre></div>
</div>
<p>Notice how we now include an <code class="docutils literal notranslate"><span class="pre">-lgeometry</span></code> option to tell the
linker to link with the <code class="docutils literal notranslate"><span class="pre">libgeometry.so</span></code> library (by default,
passing <em>NAME</em> to the <code class="docutils literal notranslate"><span class="pre">-l</span></code> option will result in the linker
searching for a file called <code class="docutils literal notranslate"><span class="pre">libNAME.so</span></code>). We additionally
pass the <code class="docutils literal notranslate"><span class="pre">-L.</span></code> option to tell the linker to look for
libraries in the current directory.</p>
<div class="admonition-what-about-lm admonition">
<p class="admonition-title">What about <code class="docutils literal notranslate"><span class="pre">-lm</span></code>?</p>
<p>We’ve used the <code class="docutils literal notranslate"><span class="pre">-lm</span></code> option previously to link
our executables to the standard math library, but
we’ve just said that using an option like <code class="docutils literal notranslate"><span class="pre">-lm</span></code>
would result in linking with with a library called
<code class="docutils literal notranslate"><span class="pre">libm.so</span></code>. So, where is that file?</p>
<p>Since the math library is a standard library,
it is located in a system directory that the
linker will also be looking at when trying
to find library files. In most Linux systems,
this file can be found here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">/</span><span class="n">libm</span><span class="o">.</span><span class="n">so</span>
</pre></div>
</div>
</div>
<p>If you run the commands above, the result should be
a <code class="docutils literal notranslate"><span class="pre">point-distance</span></code> executable. However, there is
one final wrinkle when we try to run it:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ./point-distance
./point-distance: error <span class="k">while</span> loading shared libraries: libgeometry.so: cannot open shared object file: No such file or directory
</pre></div>
</div>
<p>We also need to tell the <em>shell</em> where to look for library
files when running executables. We can do this by setting
the <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> environment variable:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">export</span> <span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>.
$ ./point-distance
<span class="o">[</span>Point <span class="m">1</span><span class="o">]</span> Please enter a value <span class="k">for</span> x: <span class="m">0</span>.0
<span class="o">[</span>Point <span class="m">1</span><span class="o">]</span> Please enter a value <span class="k">for</span> y: <span class="m">1</span>.0
<span class="o">[</span>Point <span class="m">2</span><span class="o">]</span> Please enter a value <span class="k">for</span> x: <span class="m">1</span>.0
<span class="o">[</span>Point <span class="m">2</span><span class="o">]</span> Please enter a value <span class="k">for</span> y: <span class="m">0</span>.0
The distance between <span class="o">(</span><span class="m">0</span>.00, <span class="m">1</span>.00<span class="o">)</span> and <span class="o">(</span><span class="m">1</span>.00, <span class="m">0</span>.00<span class="o">)</span> is <span class="m">1</span>.41
</pre></div>
</div>
<p>Note: Setting the <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> environment variable only needs to be done once
each time you start a new terminal. You do not need to run it every time you want
to run the executable.</p>
<p>Our updated Makefile will now look like this:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">CC</span> <span class="o">=</span> clang
<span class="nv">CFLAGS</span> <span class="o">=</span> -fPIC -g -O2 -Wall -Wextra
<span class="nv">LDFLAGS</span> <span class="o">=</span> -L.
<span class="nv">LDLIBS</span> <span class="o">=</span> -lgeometry -lm

<span class="nv">SRCS</span> <span class="o">=</span> point.c polygon.c
<span class="nv">OBJS</span> <span class="o">=</span> <span class="k">$(</span>SRCS:.c<span class="o">=</span>.o<span class="k">)</span>
<span class="nv">LIB</span> <span class="o">=</span> libgeometry.so

<span class="nv">BINS</span> <span class="o">=</span> polygon-area point-distance

<span class="nf">all</span><span class="o">:</span> <span class="k">$(</span><span class="nv">LIB</span><span class="k">)</span> <span class="k">$(</span><span class="nv">BINS</span><span class="k">)</span>

<span class="nf">.PHONY</span><span class="o">:</span> <span class="n">clean</span> <span class="n">all</span>

<span class="nf">$(OBJS)</span><span class="o">:</span> %.<span class="n">o</span>:%.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> $&lt; -c -o <span class="nv">$@</span>

<span class="nf">$(LIB)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">OBJS</span><span class="k">)</span>
    <span class="k">$(</span>CC<span class="k">)</span> -shared -o <span class="nv">$@</span> $^

<span class="nf">$(BINS)</span><span class="o">:</span> %:%.<span class="n">c</span> <span class="k">$(</span><span class="nv">LIB</span><span class="k">)</span>
    <span class="k">$(</span>CC<span class="k">)</span> $&lt; -o <span class="nv">$@</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> <span class="k">$(</span>LDLIBS<span class="k">)</span>

<span class="nf">clean</span><span class="o">:</span>
    rm -f <span class="k">$(</span>OBJS<span class="k">)</span> <span class="k">$(</span>LIB<span class="k">)</span> <span class="k">$(</span>BINS<span class="k">)</span>
</pre></div>
</div>
<p>At this point, it should be possible for you to understand the
changes we’ve made to the Makefile. Pay special attention to the
new <code class="docutils literal notranslate"><span class="pre">$(LIB)</span></code> target, and the new <code class="docutils literal notranslate"><span class="pre">BINS</span></code> variable (which now
specifies multiple executables), as well as how we’re using patterns in the
<code class="docutils literal notranslate"><span class="pre">$(BINS)</span></code> pattern to build those executables.</p>
<div class="admonition-the-directory-structure-in-homework-2-s-libgeometry admonition">
<p class="admonition-title">The directory structure in Homework #2’s libgeometry</p>
<p>If you look at the libgeometry code from Homework #2, you’ll
see that, instead of having all the .c and .h files in one directory
(as we’ve seen in the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> example), it follows a
specific directory structure:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src/</span></code>: Contains the source code for the library.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">include/</span></code>: Contains any “public” header files, meaning any header
files that we would allow other module or programs to include. Take
into account that this means we don’t just place all the header
files in the <code class="docutils literal notranslate"><span class="pre">include/</span></code> directory. For example, there is a <code class="docutils literal notranslate"><span class="pre">utils.h</span></code>
file in <code class="docutils literal notranslate"><span class="pre">src/</span></code> that is only meant to be used by the C files in that
directory, and which we would not want other modules or programs to
include.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">samples/</span></code>: Contains a sample program that uses the libgeometry library.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tests/</span></code>: Contains all test-related code.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> is also different because it will produce both a dynamic
library (<code class="docutils literal notranslate"><span class="pre">libgeometry.so</span></code>) and a static library (<code class="docutils literal notranslate"><span class="pre">libgeometry.a</span></code>). It
also produces a series of <em>dependency files</em> (<code class="docutils literal notranslate"><span class="pre">.d</span></code> files) that allow
make to keep track of dependencies between header files (you do not
need to worry about how this mechanism works).</p>
<p>Additionally, there are also Makefiles inside the <code class="docutils literal notranslate"><span class="pre">tests/</span></code> and
<code class="docutils literal notranslate"><span class="pre">samples/</span></code> directory. This is a common way to refactor Makefiles,
which allows the top-level Makefile to define targets like the <code class="docutils literal notranslate"><span class="pre">tests</span></code>
target which just say “run the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> in directory <code class="docutils literal notranslate"><span class="pre">tests/</span></code>”</p>
</div>
</div>
<div class="section" id="task-2-the-libgraph-library">
<h2>Task 2: The libgraph library<a class="headerlink" href="#task-2-the-libgraph-library" title="Permalink to this headline">¶</a></h2>
<p>We have included in your repository a <code class="docutils literal notranslate"><span class="pre">libgraph</span></code> directory that contains
the code for a graph library (in the <code class="docutils literal notranslate"><span class="pre">src/libgraph</span></code> directory),
as well as a few executables that use that library (in the <code class="docutils literal notranslate"><span class="pre">src/tools</span></code>
directory). You do not need to understand the graph code itself but,
if you’re curious, it provides a series of data structures and functions
to manipulate graphs, as well as a few common graph algorithms.</p>
<p>Your task is to write a Makefile that will build a <code class="docutils literal notranslate"><span class="pre">libgraph.so</span></code> library,
along with the <code class="docutils literal notranslate"><span class="pre">best-first</span></code> and <code class="docutils literal notranslate"><span class="pre">toposort</span></code> executables, which will
use that library. Notice how the directory structure is
different from the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code> example, where all the files
were in a single directory. Instead, the files are organized
similar to the <code class="docutils literal notranslate"><span class="pre">libgeometry</span></code> example from Homework #2.</p>
<p>You are not allowed to move any of
the files in the <code class="docutils literal notranslate"><span class="pre">libgraph/</span></code> directory, and must instead account
for this directory structure in your Makefile. One particular aspect
you’ll have to figure out (which we have not explained) is how to
tell the compiler to look for header files in a different directory
(notice how several of the header files are in a separate <code class="docutils literal notranslate"><span class="pre">include/</span></code>
directory).</p>
<p>If you are successful, you should be able to run the executables as follows:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ./best-first -g examples/cities.graph -s SanFrancisco -f NewYork
SanFrancisco -&gt; LosAngeles -&gt; LasVegas -&gt; Phoenix -&gt; SaltLakeCity -&gt; Denver -&gt; KansasCity -&gt; Minneapolis -&gt; Chicago -&gt; Cleveland -&gt; NewYork
Total weight: <span class="m">4365</span>.00
</pre></div>
</div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ./toposort -g examples/flow.graph
START R1 R2 R3 R4 R5 R6 END
</pre></div>
</div>
<p>The first executable does a <a class="reference external" href="https://en.wikipedia.org/wiki/Best-first_search">best-first search</a>
on the graph, while the second executable does a <a class="reference external" href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a>.</p>
</div>
<div class="section" id="cmake">
<h2>CMake<a class="headerlink" href="#cmake" title="Permalink to this headline">¶</a></h2>
<p>You may have noticed that both the <code class="docutils literal notranslate"><span class="pre">micro-editor</span></code> directory and the <code class="docutils literal notranslate"><span class="pre">libgraph</span></code>
directory contain a <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> file. This file is used by a build system
called <a class="reference external" href="https://cmake.org/">CMake</a> that provides a simpler file format
for specifying builds (internally, CMake actually uses regular <code class="docutils literal notranslate"><span class="pre">make</span></code> to actually
build the code). In fact, this is the build system we use in the course project.</p>
<p>We are not going to get into the full syntax of the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> file but a
quick glance at <code class="docutils literal notranslate"><span class="pre">libgraph/CMakeLists.txt</span></code> can give you a sense of how much simpler
it is than regular <code class="docutils literal notranslate"><span class="pre">Makefiles</span></code>. For example, this command specifies how
to build the libgraph library:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_library</span><span class="p">(</span><span class="s">graph</span> <span class="s">SHARED</span>
        <span class="s">src/libgraph/graph.c</span>
        <span class="s">src/libgraph/vlist.c</span>
        <span class="s">src/libgraph/algorithms.c</span><span class="p">)</span>
</pre></div>
</div>
<p>And these two commands specify how to build the <code class="docutils literal notranslate"><span class="pre">best-first</span></code> executable (including
the fact that it needs to be linked to the libgraph library):</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">best-first</span>
        <span class="s">src/tools/best-first.c</span><span class="p">)</span>

<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">best-first</span> <span class="s">graph</span><span class="p">)</span>
</pre></div>
</div>
<p>To build the code with CMake, we would run the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ cmake -B build/
</pre></div>
</div>
<p>This will create a <em>build directory</em> that will contain all the files related
to building the code (e.g., all the intermediate object files will be
created here).</p>
<p>After we’ve run that command, we can <code class="docutils literal notranslate"><span class="pre">cd</span></code> into the <code class="docutils literal notranslate"><span class="pre">build/</span></code> directory
and run <code class="docutils literal notranslate"><span class="pre">make</span></code> as usual. This will produce the <code class="docutils literal notranslate"><span class="pre">libgraph.so</span></code> file
along with the <code class="docutils literal notranslate"><span class="pre">best-first</span></code> and <code class="docutils literal notranslate"><span class="pre">toposort</span></code> executables. If you try to
run them, they should behave exactly as described earlier.</p>
</div>
<div class="section" id="submitting-your-homework">
<h2>Submitting your homework<a class="headerlink" href="#submitting-your-homework" title="Permalink to this headline">¶</a></h2>
<p>Before submitting, make sure you’ve added, committed, and pushed all
your work to GitHub. When submitting through Gradescope, you will be given the option of
uploading a GitHub repository. Make sure you select your <code class="docutils literal notranslate"><span class="pre">hw3-GITHUB_USERNAME</span></code>
repository, with “main” as the branch. Please note that you can submit as many times as
you want before the deadline.</p>
<p>Once you submit your files, an “autograder” will run. This won’t
actually be doing any grading, but it will try to build the code in
the <code class="docutils literal notranslate"><span class="pre">polygon-area</span></code>, <code class="docutils literal notranslate"><span class="pre">micro-editor</span></code>, and <code class="docutils literal notranslate"><span class="pre">libgraph</span></code> directories
(using the <code class="docutils literal notranslate"><span class="pre">Makefiles</span></code> in each directory). If the autograder shows
any errors, that is a sign there could be issues with your Makefiles.</p>
<p>Note: you may see a compiler warning referring to a “buf” variable
in the <code class="docutils literal notranslate"><span class="pre">micro-editor</span></code> code. You can safely ignore this warning.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2011-2021, The University of Chicago.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>