
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Part I: Using Containers in CI &#8212; CMSC 22000 - Introduction to Software Development</title>

    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/chiweb.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          CMSC 22000 - Introduction to Software Development</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              
              
            
            
            
<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Information <span class="caret"></span></a>
    <ul class="dropdown-menu">
        <li><a href="../syllabus.html">Syllabus</a></li>
        <li><a href="../calendar.html">Calendar</a></li>
        <li><a href="../code_of_conduct.html">TA/Grader Code of Conduct</a></li>
    </ul>
</li>
<li><a href="index.html">Homework</a></li>
<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Project <span class="caret"></span></a>
    <ul class="dropdown-menu">
        <li><a href="../project/index.html">Introduction</a></li>
        <li><a href="../project/chiventure.html">chiventure</a></li>
        <li><a href="../project/policies.html">Policies</a></li>
        <li><a href="../project/features.html">Features</a></li>
        <li><a href="../project/warmup.html">Design Warm-Up Exercise</a></li>
    </ul>
</li>
<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Resources <span class="caret"></span></a>
    <ul class="dropdown-menu">
        <li><a href="../resources/faq.html">CS 220 FAQs</a></li>
        <li><a href="../resources/tutorials/index.html">Tutorials</a></li>
        <li><a href="https://uchicago-cs.github.io/dev-guide/" target="_blank">UChicago CS Developer's Guide <i class="fa fa-external-link"></i></a></li>
        <li><a href="https://uchicago-cs.github.io/debugging-guide" target="_blank">The Debugging Guide <i class="fa fa-external-link"></i></a></li>
        <li><a href="../resources/other.html">Other Resources</a></li>
    </ul>
</li>

            
          </ul>

          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <p><strong>Due:</strong> Wednesday, June 3rd, 8pm</p>
<p>In this lab, we will continue to explore concepts related to Continuous
Integration and Deployment. The lab is divided into two main parts: one
where we will see how we can use Docker containers as part of a CI
build, and one where we will expand the deployment pipeline we saw in
our previous lab.</p>
<div class="section" id="part-i-using-containers-in-ci">
<h1>Part I: Using Containers in CI<a class="headerlink" href="#part-i-using-containers-in-ci" title="Permalink to this headline">¶</a></h1>
<p>It is often necessary for a CI build to use a specific software
environment to build code and to run tests. This may be as simple as
needing some set of libraries installed before we can build and run your
code, or as complex as running some sort of server that our code and
tests need to run.</p>
<p>In this lab, we are going to work through an example that requires a
running <a class="reference external" href="https://redis.io/">Redis</a>, a popular data structure store.
In a nutshell, Redis is a server that can store a variety of data
structures (including lists, hash tables, etc.), and which allows you to
manipulate those data structures via an API and a CLI. The API is
typically accessed remotely (i.e., the Redis server runs on one machine,
and client software running on a different machine accesses the API
through a network), which means that testing client software that relies
on Redis requires running a Redis server too.</p>
<p>Most CI systems allow you to install software before the CI jobs are
run. For example, in the previous lab you saw how to install the
Criterion testing library as part of a build (specifying the exact steps
to do so under the <code class="docutils literal notranslate"><span class="pre">before_install</span></code> and <code class="docutils literal notranslate"><span class="pre">install</span></code> steps, or using
the <code class="docutils literal notranslate"><span class="pre">addons</span></code> portion of the <code class="docutils literal notranslate"><span class="pre">.travis.yml</span></code> file). However, installing
and configuring a complex piece of software like Redis through this
mechanism can be cumbersome. It can also take a fair amount of time,
even if the installation is automated, so it can pay off to simply have
a software environment that is ready to go with all the software we
need.</p>
<p>One way of doing this is by using <em>containers</em>, a sort of lightweight
virtual machine that provides a specific software environment we need.
Unlike virtual machines, containers are typically used to package a
specific piece of software, instead of providing a full OS environment
(although this is also possible with containers)</p>
<p>For example, a Redis container would include a Redis server and, by
default, running the container would immediately start that Redis
server, instead of taking us to a UNIX shell where we have to run the
Redis server ourselves. So, if we wanted to run Redis during a CI build,
all we would need to do is download a Redis <em>container image</em>, and run
that container during the CI build. A popular container manager is
<a class="reference external" href="https://www.docker.com/">Docker</a>, which we will be using in this
lab. Make sure to read their <a class="reference external" href="https://www.docker.com/what-container">What is a
Container</a> page, which
provides a more in-depth explanation of what a container is, and how it
compares to virtual machines.</p>
<div class="section" id="creating-your-lab-repository">
<h2>Creating your lab repository<a class="headerlink" href="#creating-your-lab-repository" title="Permalink to this headline">¶</a></h2>
<p>Like previous labs, we will provide you with an <em>invitation URL</em> that
will allow you sign up for the lab assignment on GitHub, and which will
result in the creation of a repository called
<code class="docutils literal notranslate"><span class="pre">2020-lab8-GITHUB_USERNAME</span></code> inside our <code class="docutils literal notranslate"><span class="pre">cmsc22000-labs</span></code> organization
on GitHub. Your repository will be seeded with some files for the lab
and, more specifically, will contain some code that requires a Redis
server to run correctly.</p>
</div>
<div class="section" id="task-1-running-docker-in-the-cs-vm">
<h2>Task 1: Running Docker in the CS VM<a class="headerlink" href="#task-1-running-docker-in-the-cs-vm" title="Permalink to this headline">¶</a></h2>
<p>[0 Points]</p>
<p>{{% note %}} This is an optional task, and you will be able to complete
the lab even if you don’t do this task. However, even if you do not
perform the steps in this task, you should still read through the task,
as it provides some additional details on how Redis works. {{% /note %}}</p>
<p>Using Docker requires <a class="reference external" href="https://en.wikipedia.org/wiki/Superuser">root
privileges</a>, which you do
not have on the CSIL machines. Fortunately, as we’ll see later on, that
won’t stop us from running Docker on Travis, but it does mean that you
won’t get to use Docker yourself (you’ll simply be instructing Travis to
use Docker)</p>
<p>However, it can be helpful to learn the basics of how to use Docker, and
you can do so using the <a class="reference external" href="https://howto.cs.uchicago.edu/vm:index">UChicago CS Virtual
Machine</a>, where you do have
the ability to run commands with root privileges. In particular, we
encourage you to use the VM in <a class="reference external" href="https://howto.cs.uchicago.edu/vm:headless">Headless
Mode</a>.</p>
<p>Completing this task requires running the VM on your own machine (not on
a CSIL machine), so this task is optional and ungraded, but strongly
recommended, specially if you’ve already installed the UChicago CS VM.</p>
<p>Once you’ve started the UChicago CS VM, open a terminal. We will first
need to install Redis and Docker on the virtual machine. You can install
Redis by running the following commands (these instructions are based on
the official Redis <a class="reference external" href="https://redis.io/download">installation
documentation</a>):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ wget http://download.redis.io/redis-stable.tar.gz
$ tar xzf redis-stable.tar.gz
$ <span class="nb">cd</span> redis-stable/
$ make
$ sudo make install
</pre></div>
</div>
<p>Notice how that last command is run with <code class="docutils literal notranslate"><span class="pre">sudo</span></code>. This basically
instructs the operating system to run the command (<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code>)
with root privileges. You will be asked to enter your password which, on
the CS VM, is <code class="docutils literal notranslate"><span class="pre">uccs</span></code> by default. The reason we need to run this
command with <code class="docutils literal notranslate"><span class="pre">sudo</span></code> is because it involves installing the Redis
libraries and binaries in system-wide locations, which require root
privileges to modify.</p>
<p>Now, go back to the terminal and run the following commands (these are
based on the official Docker <a class="reference external" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">installation
documentation</a>):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ sudo apt update
$ sudo apt install -y apt-transport-https ca-certificates curl software-properties-common gnupg-agent
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg <span class="p">|</span> sudo apt-key add -
$ sudo apt-key fingerprint 0EBFCD88
$ sudo add-apt-repository <span class="s2">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu </span><span class="k">$(</span>lsb_release -cs<span class="k">)</span><span class="s2"> stable&quot;</span>
$ sudo apt-get update
$ sudo apt-get install -y docker-ce
</pre></div>
</div>
<p>You can verify that Docker is correctly installed by running this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo docker run hello-world
</pre></div>
</div>
<p>This will run a container whose sole purpose is to print out a welcome
message. If you do not see a message that starts with “Hello from
Docker!”, please ask for help.</p>
<p>We can run a Redis container simply by running the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo docker run --name redis-server -p <span class="m">6379</span>:6379 redis
</pre></div>
</div>
<p>Docker will first download the Redis container image from the <a class="reference external" href="https://hub.docker.com/_/redis/">Docker
Hub</a>, and then run it. You should
see some output that ends with something like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="m">1</span>:M <span class="m">17</span> May <span class="m">14</span>:04:54.269 * Ready to accept connections
</pre></div>
</div>
<p>Now, open another terminal in the VM and run this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>redis-cli
</pre></div>
</div>
<p>(if you are running the VM in Headless Mode, then you will need to SSH
into it again to have a second terminal)</p>
<p>This should open up a prompt like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="m">127</span>.0.0.1:6379&gt;
</pre></div>
</div>
<p>This means that the Redis CLI tool running on your VM has successfully
connected to the Redis server running inside the Docker container.
However, notice how we’re not running Redis directly on the VM (we
installed Redis so we could use the <code class="docutils literal notranslate"><span class="pre">redis-cli</span></code> tool, but we never ran
the <code class="docutils literal notranslate"><span class="pre">redis-server</span></code> command on the VM).</p>
<p>You can now try running a few Redis commands from the Redis CLI:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="m">127</span>.0.0.1:6379&gt; SET foo <span class="m">42</span>
OK
<span class="m">127</span>.0.0.1:6379&gt; GET foo
<span class="s2">&quot;42&quot;</span>
<span class="m">127</span>.0.0.1:6379&gt; HSET myhash name <span class="s2">&quot;Borja&quot;</span>
<span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
<span class="m">127</span>.0.0.1:6379&gt; HGET myhash name
<span class="s2">&quot;Borja&quot;</span>
<span class="m">127</span>.0.0.1:6379&gt; HSET myhash email <span class="s2">&quot;borja@cs.uchicago.edu&quot;</span>
<span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
<span class="m">127</span>.0.0.1:6379&gt; HKEYS myhash
<span class="m">1</span><span class="o">)</span> <span class="s2">&quot;name&quot;</span>
<span class="m">2</span><span class="o">)</span> <span class="s2">&quot;email&quot;</span>
</pre></div>
</div>
<p>On a separate terminal, you can also try running a few Docker commands:</p>
<ul class="simple">
<li><p>To see the list of container images: <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">image</span> <span class="pre">list</span></code></p></li>
<li><p>To see the list of running containers: <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">container</span> <span class="pre">list</span></code></p></li>
<li><p>To stop the Redis container:
<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">container</span> <span class="pre">stop</span> <span class="pre">redis-server</span></code></p></li>
<li><p>To start the Redis container again:
<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">container</span> <span class="pre">start</span> <span class="pre">-a</span> <span class="pre">redis-server</span></code></p></li>
</ul>
</div>
<div class="section" id="task-2-git-submodules">
<h2>Task 2: Git Submodules<a class="headerlink" href="#task-2-git-submodules" title="Permalink to this headline">¶</a></h2>
<p>[20 points]</p>
<p>Your lab repository contains code that extends the Redis server with
some additional commands. We will only be concerned with one of these
commands: the <code class="docutils literal notranslate"><span class="pre">EXAMPLE.HGETSET</span></code> command. This commands operates on a
hash table and takes two parameters: a key and a value. It will fetch
the value currently associated with the given key, and will replace its
value with the one provided as a parameter. For example, notice how the
example below fetches the current value of the <code class="docutils literal notranslate"><span class="pre">email</span></code> key, while also
replacing it with a new value:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="m">127</span>.0.0.1:6379&gt; HSET myhash name <span class="s2">&quot;Borja&quot;</span>
<span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
<span class="m">127</span>.0.0.1:6379&gt; HSET myhash email <span class="s2">&quot;borja@cs.uchicago.edu&quot;</span>
<span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
<span class="m">127</span>.0.0.1:6379&gt; EXAMPLE.HGETSET myhash email <span class="s2">&quot;borja@uchicago.edu&quot;</span>
<span class="s2">&quot;borja@cs.uchicago.edu&quot;</span>
<span class="m">127</span>.0.0.1:6379&gt; HGET myhash email
<span class="s2">&quot;borja@uchicago.edu&quot;</span>
</pre></div>
</div>
<p>The repository has two directories:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">module/</span></code> - This directory contains the module that implements the
new commands (Note: in Redis, the term “module” has a specific
meaning, and it refers to an installable component that extends
Redis).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tests/</span></code> - This directory contains a simple program that uses the
hiredis library to connect to a Redis server to test the <code class="docutils literal notranslate"><span class="pre">HGETSET</span></code>
operation.</p></li>
</ul>
<p>To compile the module code, we will need some files included in the
Redis Module SDK (Software Development Kit) available in the following
repo: <a class="reference external" href="https://github.com/RedisLabs/RedisModulesSDK">https://github.com/RedisLabs/RedisModulesSDK</a>. To compile the
testing program, we also need the hiredis library, which is available in
this repository: <a class="reference external" href="https://github.com/redis/hiredis">https://github.com/redis/hiredis</a>.</p>
<p>We could, of course, just clone those repositories and copy them into
our repository. This is usually a bad idea, because it makes it harder
to track updates in the original code. For example, if hiredis releases
a new version, we would have to manually copy over their updated version
into our repository.</p>
<p>In general, the problem we’re facing is that there is some code produced
by a “third party” that we would like to include in our project. In Git
this is typically handled by using <em>submodules</em>, which effectively allow
us to include “third party repositories” in our own repository (in other
version control systems, this is sometimes referred to as “vendor
branches”).</p>
<p>We can add submodules by using the <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">submodule</span></code> command:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ git submodule add https://github.com/RedisLabs/RedisModulesSDK.git
Cloning into <span class="s1">&#39;/tmp/2020-lab8-GITHUB_USERNAME/RedisModulesSDK&#39;</span>...
remote: Counting objects: <span class="m">439</span>, <span class="k">done</span>.
remote: Total <span class="m">439</span> <span class="o">(</span>delta <span class="m">0</span><span class="o">)</span>, reused <span class="m">0</span> <span class="o">(</span>delta <span class="m">0</span><span class="o">)</span>, pack-reused <span class="m">439</span>
Receiving objects: <span class="m">100</span>% <span class="o">(</span><span class="m">439</span>/439<span class="o">)</span>, <span class="m">187</span>.79 KiB <span class="p">|</span> <span class="m">1</span>.59 MiB/s, <span class="k">done</span>.
Resolving deltas: <span class="m">100</span>% <span class="o">(</span><span class="m">258</span>/258<span class="o">)</span>, <span class="k">done</span>.

$ git submodule add https://github.com/redis/hiredis.git
Cloning into <span class="s1">&#39;/tmp/2020-lab8-GITHUB_USERNAME/hiredis&#39;</span>...
remote: Counting objects: <span class="m">2909</span>, <span class="k">done</span>.
remote: Compressing objects: <span class="m">100</span>% <span class="o">(</span><span class="m">13</span>/13<span class="o">)</span>, <span class="k">done</span>.
remote: Total <span class="m">2909</span> <span class="o">(</span>delta <span class="m">9</span><span class="o">)</span>, reused <span class="m">19</span> <span class="o">(</span>delta <span class="m">9</span><span class="o">)</span>, pack-reused <span class="m">2887</span>
Receiving objects: <span class="m">100</span>% <span class="o">(</span><span class="m">2909</span>/2909<span class="o">)</span>, <span class="m">866</span>.09 KiB <span class="p">|</span> <span class="m">5</span>.16 MiB/s, <span class="k">done</span>.
Resolving deltas: <span class="m">100</span>% <span class="o">(</span><span class="m">1791</span>/1791<span class="o">)</span>, <span class="k">done</span>.
</pre></div>
</div>
<p>You’ll notice that two new directories have appeared in your repository,
containing the files that are in the original RedisModulesSDK and
hiredis repositories.</p>
<p>Before we continue, we need to commit these submodules. If you run
<code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">status</span></code>, you’ll see that Git is aware that we’ve added two
submodules (they are tracked in a special file called <code class="docutils literal notranslate"><span class="pre">.gitmodules</span></code>)
but they have not yet been committed:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ git status
On branch master
Your branch is up to date with <span class="s1">&#39;origin/master&#39;</span>.

Changes to be committed:
  <span class="o">(</span>use <span class="s2">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage<span class="o">)</span>

    new file:   .gitmodules
    new file:   RedisModulesSDK
    new file:   hiredis
</pre></div>
</div>
<p>So, simply run the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ git commit -m<span class="s2">&quot;Added submodules&quot;</span>
$ git push
</pre></div>
</div>
<p>If you go to your repo on the GitHub website, you’ll see that the
submodules are shown in a different way: Git is aware that, instead of
just copying over the files into your repository, it should simply point
to other repositories.</p>
<p>Now, it will be possible for you to build hiredis, as well as the module
and the tests:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make -C hiredis/
$ make -C module/
$ make -C tests/
</pre></div>
</div>
<p>However, you can’t run any of this just yet. We need a Redis server for
that!</p>
<p>{{% warning %}} Cloning a repository does not automatically clone the
submodules in that repository, instead showing them as empty
directories. If you clone your repository somewhere else, you need to
clone it like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>git clone --recursive REPO_URL
</pre></div>
</div>
<p>If you forgot to use the <code class="docutils literal notranslate"><span class="pre">--recursive</span></code> option, you can also do this
after the repository has been cloned:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>git submodule update --init --recursive
</pre></div>
</div>
<p>{{% /warning %}}</p>
<p>For this task, you won’t need to enter anything into Gradescope, but
make sure you’ve successfully pushed the submodules to your GitHub
repository.</p>
</div>
<div class="section" id="task-3-using-docker-in-a-travis-build">
<h2>Task 3: Using Docker in a Travis build<a class="headerlink" href="#task-3-using-docker-in-a-travis-build" title="Permalink to this headline">¶</a></h2>
<p>[30 points]</p>
<p>Testing the module requires running Redis, so we will need to set up our
Travis build to run a Redis server while testing our module. We will do
this by telling Travis to use a Docker container with Redis installed in
it, and to run our module in that container.</p>
<p>Our container is specified using the <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> file. You do not
need to understand everything in that file, except that we use the
<code class="docutils literal notranslate"><span class="pre">FROM</span> <span class="pre">redis</span></code> command to tell Docker that our container should simply
use the standard Redis container that is available on the Docker Hub.
Then, all we need to do is install our module in it, and make sure that
we start Redis with the <code class="docutils literal notranslate"><span class="pre">--loadmodule</span></code> option to load our module.</p>
<p>{{% note %}} If you’ve set up Docker on your VM, you can also test the
module on the VM, essentially running the same commands that Travis will
be running. Start by cloning your repository inside the VM:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ git clone --recursive https://github.com/cmsc22000-labs/2020-lab8-GITHUB_USERNAME.git
</pre></div>
</div>
<p>Then, go into the repository directory:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">cd</span> <span class="m">2020</span>-lab8-GITHUB_USERNAME
</pre></div>
</div>
<p>And use this command to build a container image with Redis <em>and</em> our
module:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ sudo docker build -t redis-example .
</pre></div>
</div>
<p>This may take a while, as Docker has to download a number of other
container images to build ours.</p>
<p>Finally, you can run the container like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ sudo docker run -d -p <span class="m">6379</span>:6379 redis-example
</pre></div>
</div>
<p>If you need to stop the container later on, simply press Ctrl+C.</p>
<p>In a separate terminal, build hiredis and the tests:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ make -C hiredis/
$ make -C tests/
</pre></div>
</div>
<p>You should now be able to run the test program:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ./tests/test-hgetset
PING: PONG
HSET: <span class="o">(</span>null<span class="o">)</span>
HGETSET: Random J. Redisuser
HGET: Alan T. Foobar
</pre></div>
</div>
<p>{{% /note %}}</p>
<p>Add a <code class="docutils literal notranslate"><span class="pre">.travis.yml</span></code> file to your repository with the following
contents:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dist</span><span class="p">:</span> <span class="n">xenial</span>

<span class="n">language</span><span class="p">:</span> <span class="n">c</span>

<span class="n">services</span><span class="p">:</span>
  <span class="o">-</span> <span class="n">docker</span>

<span class="n">before_install</span><span class="p">:</span>
  <span class="o">-</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">redis</span><span class="o">-</span><span class="n">example</span> <span class="o">.</span>
  <span class="o">-</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">p</span> <span class="mi">6379</span><span class="p">:</span><span class="mi">6379</span> <span class="n">redis</span><span class="o">-</span><span class="n">example</span>
  <span class="o">-</span> <span class="n">docker</span> <span class="n">container</span> <span class="nb">list</span>

<span class="n">script</span><span class="p">:</span>
 <span class="o">-</span> <span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="n">hiredis</span><span class="o">/</span>
 <span class="o">-</span> <span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="n">tests</span><span class="o">/</span>
 <span class="o">-</span> <span class="o">./</span><span class="n">tests</span><span class="o">/</span><span class="n">test</span><span class="o">-</span><span class="n">hgetset</span>
</pre></div>
</div>
<p>Go ahead and commit and push this file. The Travis build may take a few
minutes; just read ahead before checking the status of your build.</p>
<p>There are a few differences with the Travis files we’ve seen previously:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">services</span></code> option tells Travis that we will need access to
Docker’s tools, which includes the ability to build and run our own
containers.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">before_install</span></code> option includes the Docker commands we need to
run our container. Notice how they’re the same as the ones you can
run insider your VM. We’ve also included <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">list</span></code> to
double-check that our container is running.</p></li>
</ul>
<p>Other than that, the <code class="docutils literal notranslate"><span class="pre">script</span></code> portion should be pretty
self-explanatory: we build hiredis and the tests, and we run the sample
program.</p>
<p>The build on Travis may take a few minutes, as it will need to download
the necessary container images before it can build and run our code. If
the build succeeds, you should be able to see this towards the end of
the build’s output:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ ./tests/test-hgetset
PING: PONG
HSET: <span class="o">(</span>null<span class="o">)</span>
HGETSET: Random J. Redisuser
HGET: Alan T. Foobar
</pre></div>
</div>
<p>If the build fails or you do not see this output, make sure to ask for
help.</p>
<p>For this task, please enter the URL of your successful Travis build on
Gradescope.</p>
</div>
</div>
<div class="section" id="part-ii-a-complete-deployment-pipeline">
<h1>Part II: A complete deployment pipeline<a class="headerlink" href="#part-ii-a-complete-deployment-pipeline" title="Permalink to this headline">¶</a></h1>
<p>In class, we have discussed that software is rarely deployed directly
into production but, instead, follows a <em>deployment pipeline</em>. In our
previous lab we saw a very basic deployment pipeline: we set up our
HelloApp to deploy to Heroku, but only if the CI tests passed. In this
lab, we are going to see a more complete deployment pipeline.</p>
<p>As we saw in the deployment lecture, a common pipeline is as follows:</p>
<ul class="simple">
<li><p><em>Local</em>, where you are the only one making changes to your codebase.</p></li>
<li><p><em>Staging</em>, where all developers can see your changes, but you have
time to catch errors before showing the end-users.</p></li>
<li><p><em>Production</em>, where your app is available to the real world. Usually,
the staging app will be promoted to production when it is ready.</p></li>
</ul>
<p>In this lab, you’ll create a more complete Heroku pipeline for last
week’s HelloApp. If you did not successfully complete Lab 7, please ask
for help so we can ensure that you’re all set up for this week’s lab.</p>
<p>Heroku already provides support for creating pipelines, and ours will
have three stages:</p>
<ul class="simple">
<li><p><em>Review</em>: Similar to a development stage. In Heroku, we can
automatically link this stage to our pull requests on GitHub, so we
can easily test any changes we are proposing in a pull request.</p></li>
<li><p><em>Staging</em>: We will be using the app you created in Lab 7 as our
staging app.</p></li>
<li><p><em>Production</em>: A new production app that is only available if we are
satisfied with our staging app.</p></li>
</ul>
<div class="section" id="task-1-create-a-pipeline">
<h2>Task 1: Create a Pipeline<a class="headerlink" href="#task-1-create-a-pipeline" title="Permalink to this headline">¶</a></h2>
<p>[0 points]</p>
<p>In this task, you’ll create a new Heroku Pipeline, using the the
<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-lab7</span></code> application (from last week’s lab) as the staging
application. Note that a common convention is for staging applications
to have <code class="docutils literal notranslate"><span class="pre">-staging</span></code> as a suffix, but it won’t be necessary for you to
rename your app in this lab.</p>
<p>To create the pipeline, log into Heroku, and select the app you created
in Lab 7. Under the deploy tab, click on “Choose a pipeline” (in the
“Add this app to a pipeline” section) and then “Create new pipeline”.
Name your pipeline <code class="docutils literal notranslate"><span class="pre">CNETID-pipeline</span></code> (where <code class="docutils literal notranslate"><span class="pre">CNETID</span></code> should be
replaced with your CNetID). You will also be asked to specify “Choose a
stage to add this app to”. Make sure that “staging” is selected.
Finally, click on “Create pipeline”.</p>
<p>You will now be shown the pipeline’s configuration (you will also be
able to access this page through your dashboard, which will now include
a <code class="docutils literal notranslate"><span class="pre">CNETID-pipeline</span></code> pipeline). Notice how there is no production
application in your pipeline. In the real world, this would mean that
your end users don’t see anything!</p>
<p>Please note that you do not need to enter anything into Gradescope for
this task. While it is worth 0 points, you still need to create a
pipeline before moving on to the next tasks.</p>
</div>
<div class="section" id="task-2-add-a-production-application">
<h2>Task 2: Add a production application<a class="headerlink" href="#task-2-add-a-production-application" title="Permalink to this headline">¶</a></h2>
<p>[10 points]</p>
<p>In this task, you’ll add a production application to your pipeline.
Unlike the app in staging, your production app won’t be associated with
any specific repo. Instead, once your staging application is good to go,
you can <em>promote</em> it to be the production application. That means the
production application will just take the staging app, make a copy of
it, and run that copy as the production app. This means that, if you
make changes to the staging app, those changes whon’t appear in
production until you explicitly promote the staging app to production
again.</p>
<p>Later in the lab you may see Heroku messages that talk about “slugs”; in
Heroku parlance, a “slug” is a pre-compiled version of your app that is
ready to run. So, when we promote to production, we don’t actually
rebuild the application; we just take the “slug” that is in staging, and
copy it to production.</p>
<p>To add a production application, all you have to do is go to your
pipeline and, under “Production”, click on “Add app” and then “Create
new app”. Name the application <code class="docutils literal notranslate"><span class="pre">CNETID-cs220-prod</span></code> (where <code class="docutils literal notranslate"><span class="pre">CNETID</span></code>
should be replaced with your CNetID). Notice how, if you try to access
your app on Heroku (just go to <a class="reference external" href="http://CNETID-cs220-prod.herokuapp.com/">http://CNETID-cs220-prod.herokuapp.com/</a>),
you’ll just see a placeholder page, not HelloApp. That’s because we
haven’t promoted our staging app to production yet.</p>
<p>On Gradescope, enter the URL of your staging app.</p>
</div>
<div class="section" id="task-3-promoting-from-staging-to-production">
<h2>Task 3: Promoting from staging to production<a class="headerlink" href="#task-3-promoting-from-staging-to-production" title="Permalink to this headline">¶</a></h2>
<p>[20 points]</p>
<p>First, let’s make a change to our HelloApp: it’s time to upgrade to
HelloApp 2.0!</p>
<ul class="simple">
<li><p>In your repository from Lab 7 (<code class="docutils literal notranslate"><span class="pre">2020-lab7-GITHUB_USERNAME</span></code>), edit
<code class="docutils literal notranslate"><span class="pre">hello/templates/base.html</span></code> and change “Helloapp” to “Helloapp
2.0”.</p></li>
<li><p>Commit and push this change with the message “Update to 2.0”</p></li>
<li><p>Assuming you completed Lab 7 last week, your updated app will
automatically deploy. Remember this may take a few minutes (you can
check the progress of the deployment by going to the “Activity” tab
in your app)</p></li>
</ul>
<p>Now, notice that if you navigate to your staging website
(<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-lab7.herokuapp.com</span></code>) you’ll see your change. But if you
navigate to your production website
(<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-prod.herokuapp.com</span></code>), you’ll still see a placeholder
page.</p>
<p>Why is this? Changes from staging are <em>not</em> automatically deployed to
production. This is intentional: we often don’t want things to
automatically deploy to production, since we might risk breaking the
public-facing version of our app. Pushing code that is broken is known
as “breaking the build”, and you absolutely don’t want that to propagate
to production (by the way, if you know anyone who has done a software
development internship or works in software development, ask them if
they’ve ever “broken the build”; we guarantee you’ll hear some
entertaning stories). By having a pipeline, we can ensure that users
continuously see our production, without mistakes, and we only update it
when we’re absolutely sure.</p>
<p>So, let’s go ahead and promote our staging application to production.
You can do this simply by pressing the “Promote to production…” button
in the staging app of your pipeline. Once you do this, your staging app
(<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-lab7.herokuapp.com</span></code>) and your production app
(<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-prod.herokuapp.com</span></code>) should look exactly the same.</p>
<p>On Gradescope, enter the URL of your production app.</p>
</div>
<div class="section" id="task-4-create-review-apps-helloapp-3-0">
<h2>Task 4: Create Review Apps - Helloapp 3.0<a class="headerlink" href="#task-4-create-review-apps-helloapp-3-0" title="Permalink to this headline">¶</a></h2>
<p>[20 points]</p>
<p>Currently, in order to make changes to staging, you have to directly
modify the master branch of your repo. Can you imagine why this is a bad
idea?</p>
<p>In order to show your changes to anyone, you’d have to directly change
staging, which isn’t as bad as directly modifying production, but could
be embarrassing if you’re trying to get a small change approved and then
break everything for every other developer in your team!</p>
<p>The last thing you’ll do is create a review app stage for your pipeline.
This way, every pull request submitted to GitHub can be its own app.
This lets developers see changes per-pull request.</p>
<p>To do this, we first need to connect the pipeline to GitHub:</p>
<ul class="simple">
<li><p>From the pipeline page on Heroku, click on “Connect to GitHub”</p></li>
<li><p>This will take you to a different page. Under “Search for a
repository to connect to”, select the “cmsc22000-labs” organization,
and then enter your repository’s name
(<code class="docutils literal notranslate"><span class="pre">2020-lab7-GITHUB_USERNAME</span></code>). Make sure to click on the “Search
button”</p></li>
<li><p>Finally, click on the “Connect” button next to your repository’s
name.</p></li>
</ul>
<p>Now, from your pipeline’s page, do the following:</p>
<ul class="simple">
<li><p>Click on “Enable Review Apps”. This will show you a form on the side
of the page.</p></li>
<li><p>Enable “Create new review apps for new pull requests automatically”</p></li>
<li><p>Do NOT enable “Wait for CI to pass” (this refers to Heroku’s own CI,
and we are already using Travis for CI)</p></li>
<li><p>Enable “Destroy stale review apps automatically”</p></li>
<li><p>Don’t worry about the “Review apps may incur dyno and add-on
charges.” message. We are using the free tier of Heroku, so we won’t
be charged for anything. If you want to be extra sure, go to
<a class="reference external" href="https://dashboard.heroku.com/account/billing">https://dashboard.heroku.com/account/billing</a> and make sure there is
no credit card on file for your account, and that you have free hours
available under “Free Dyno Usage”.</p></li>
<li><p>Click on “Enable Review Apps”</p></li>
</ul>
<p>Now, you’ll create a pull request:</p>
<ul class="simple">
<li><p>Create a new branch called <code class="docutils literal notranslate"><span class="pre">create-version-3</span></code> in your
<code class="docutils literal notranslate"><span class="pre">2020-lab7-GITHUB_USERNAME</span></code> repository.</p></li>
<li><p>Edit <code class="docutils literal notranslate"><span class="pre">hello/templates/base.html</span></code> and change “Helloapp 2.0” to
“Helloapp 3.0”.</p></li>
<li><p>Commit and push the changes with the message “Update to 3.0”</p></li>
<li><p>Notice how the change won’t show up on
<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-lab7.herokuapp.com</span></code>, because we haven’t pushed the
changes to <code class="docutils literal notranslate"><span class="pre">master</span></code>.</p></li>
<li><p>Now, on GitHub, create a new pull request. Make sure your pull
request is to merge the <code class="docutils literal notranslate"><span class="pre">create-version-3</span></code> branch to the <code class="docutils literal notranslate"><span class="pre">master</span></code>
branch of your repository. You do not need to assign any reviewers to
this pull request, nor do you need to worry about writing a summary,
etc.</p></li>
<li><p>On your heroku Dashboard, you should see a new application under
“Review Apps” (with the name of the pull request: “Updated to 3.0”)</p></li>
</ul>
<p>Click on “Open app” to view the review app. This allows you to see what
your app would look like if the changes in the pull request were
deployed. The review app should show the title “HelloApp 3.0”, while
both the staging (<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-lab7.herokuapp.com</span></code>) and production
(<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-prod.herokuapp.com</span></code>) apps should still show “HelloApp
2.0”</p>
<p>If the review app correctly shows the title “HelloApp 3.0”, go ahead and
merge your PR (remember, you don’t need to wait to get a review; just go
ahead and merge the pull request). This should push the changes to
staging, since you set up automatic deploys for your app (please note
that it may take a few minutes for this to happen). Once this succeeds,
go ahead and promote your final app to production.</p>
<p>Please note that, once you merge the pull request, the review app will
disappear. This is normal.</p>
<p>On Gradescope, enter the URL of the pull request you created on GitHub.</p>
<div class="section" id="submitting-your-lab">
<h3>Submitting your lab<a class="headerlink" href="#submitting-your-lab" title="Permalink to this headline">¶</a></h3>
<p>In this lab, you just need to enter a few URLs into Gradescope (make
sure you’ve done so at the points instructed above). You should also
make sure you’ve pushed your code to GitHub (but you will not be
submitting your code through Gradescope; we just need to check that
you’ve made the commits we expected you to make).</p>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2011-2021, The University of Chicago.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>