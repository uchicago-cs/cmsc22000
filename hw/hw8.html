
<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

<title>Homework 8: More CI and Deployment &#8212; CMSC 22000 - Introduction to Software Development</title>

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css?v=0bf093e7" />
    <link rel="stylesheet" type="text/css" href="../_static/chiweb.css?v=4e80c602" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Homework 8 Rubric" href="hw8_rubric.html" />
    <link rel="prev" title="Homework 7 Rubric" href="hw7_rubric.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>

  </head><body>


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          CMSC 22000 - Introduction to Software Development</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              
              
            
            
            
<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Information <span class="caret"></span></a>
    <ul class="dropdown-menu">
        <li><a href="../syllabus.html">Syllabus</a></li>
        <li><a href="../calendar.html">Calendar</a></li>
        <li><a href="../code-of-conduct.html">Code of Conduct for Course Staff</a></li>
    </ul>
</li>
<li><a href="index.html">Homework</a></li>
<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Project <span class="caret"></span></a>
    <ul class="dropdown-menu">
        <li><a href="../project/index.html">Introduction</a></li>
        <li><a href="../project/chiventure.html">chiventure</a></li>
        <li><a href="../project/policies.html">Policies</a></li>
        <li><a href="../project/issue-pr-grading.html">Issue/PR Grading</a></li>
        <li><a href="../project/features.html">Features</a></li>
    </ul>
</li>
<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Resources <span class="caret"></span></a>
    <ul class="dropdown-menu">
        <li><a href="../resources/faq.html">CS 220 FAQs</a></li>
        <li><a href="../resources/tutorials/index.html">Tutorials</a></li>
        <li><a href="https://uchicago-cs.github.io/dev-guide/" target="_blank">UChicago CS Developer's Guide <i class="fa fa-external-link"></i></a></li>
        <li><a href="https://uchicago-cs.github.io/debugging-guide" target="_blank">The Debugging Guide <i class="fa fa-external-link"></i></a></li>
        <li><a href="../resources/other.html">Other Resources</a></li>
    </ul>
</li>

            
          </ul>

          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Homework 8: More CI and Deployment</a><ul>
<li><a class="reference internal" href="#part-i-using-containers-in-ci">Part I: Using Containers in CI</a><ul>
<li><a class="reference internal" href="#creating-your-homework-repository">Creating your homework repository</a></li>
<li><a class="reference internal" href="#task-1-git-submodules">Task 1: Git Submodules</a></li>
<li><a class="reference internal" href="#task-2-using-a-container-ized-service-in-a-github-actions-workflow">Task 2: Using a Container-ized Service in a GitHub Actions workflow</a></li>
<li><a class="reference internal" href="#optional-task-3-running-docker-in-the-cs-vm">[OPTIONAL] Task 3: Running Docker in the CS VM</a></li>
<li><a class="reference internal" href="#task-4-using-a-custom-dockerfile-in-our-workflow">Task 4: Using a Custom Dockerfile in our Workflow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#part-ii-a-complete-deployment-pipeline">Part II: A Complete Deployment Pipeline</a><ul>
<li><a class="reference internal" href="#task-1-create-a-pipeline">Task 1: Create a Pipeline</a></li>
<li><a class="reference internal" href="#task-2-add-a-production-app">Task 2: Add a production app</a></li>
<li><a class="reference internal" href="#task-3-promoting-from-staging-to-production">Task 3: Promoting from staging to production</a></li>
<li><a class="reference internal" href="#addendum-review-apps">Addendum: Review Apps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#submitting-your-homework">Submitting your homework</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <section id="homework-8-more-ci-and-deployment">
<h1>Homework 8: More CI and Deployment<a class="headerlink" href="#homework-8-more-ci-and-deployment" title="Link to this heading">¶</a></h1>
<p><strong>Due:</strong> Wednesday, May 25th, 8pm CDT</p>
<p>In this homework, we will continue to explore concepts related to Continuous
Integration and Deployment. The homework is divided into two main parts: one
where we will see how we can use Docker containers as part of a CI
build, and one where we will expand the deployment pipeline we saw in
our previous homework.</p>
<section id="part-i-using-containers-in-ci">
<h2>Part I: Using Containers in CI<a class="headerlink" href="#part-i-using-containers-in-ci" title="Link to this heading">¶</a></h2>
<p>It is often necessary for a CI build to use a specific software
environment to build code and to run tests. This may be as simple as
needing some set of libraries installed before we can build and run your
code, or as complex as running some sort of server that our code and
tests need to run.</p>
<p>In this homework, we are going to work through an example that requires a
running <a class="reference external" href="https://redis.io/">Redis</a>, a popular data structure store.
In a nutshell, Redis is a server that can store a variety of data
structures (including lists, hash tables, etc.), and which allows you to
manipulate those data structures via an API (Application Programming Interface) and a CLI. The API is
typically accessed remotely (i.e., the Redis server runs on one machine,
and client software running on a different machine accesses the API
through a network), which means that testing client software that relies
on Redis requires running a Redis server too.</p>
<p>In Homework #6, we saw how you can install a software dependency (the
Criterion testing library) as part of a GitHub Actions workflow, by
specifying the exact installation commands in one of the steps of the
workflow. In general, most CI systems will allow you to install additional
software to run your CI jobs. However, installing
and configuring a complex piece of software like Redis through this
mechanism can be cumbersome. It can also take a fair amount of time,
even if the installation is automated, so it can pay off to simply have
a software environment that is ready to go with all the software we
need.</p>
<p>One way of doing this is by using <em>containers</em>, a sort of lightweight
virtual machine that provides a specific software environment we need.
Unlike virtual machines, containers are typically used to package a
specific piece of software, instead of providing a full OS environment
(although this is also possible with containers).</p>
<p>For example, a Redis container would include a Redis server and, by
default, running the container would immediately start that Redis
server, instead of taking us to a UNIX shell where we have to run the
Redis server ourselves. So, if we wanted to run Redis during a CI build,
all we would need to do is download a Redis <em>container image</em>, and run
that container during the CI build. A popular container manager is
<a class="reference external" href="https://www.docker.com/">Docker</a>, which we will be using in this
homework. Make sure to read their <a class="reference external" href="https://www.docker.com/what-container">What is a
Container</a> page, which
provides a more in-depth explanation of what a container is, and how it
compares to virtual machines.</p>
<section id="creating-your-homework-repository">
<h3>Creating your homework repository<a class="headerlink" href="#creating-your-homework-repository" title="Link to this heading">¶</a></h3>
<p>Like previous homeworks, we will provide you with an <em>invitation URL</em> that
will allow you sign up for the homework assignment on GitHub, and which will
result in the creation of a repository called
<code class="docutils literal notranslate"><span class="pre">hw8-GITHUB_USERNAME</span></code> inside our <code class="docutils literal notranslate"><span class="pre">uchicago-cmsc22000-2022</span></code> organization
on GitHub.</p>
<p>Your repository will be seeded with some files for the homework
and, more specifically, will contain some code that requires a Redis
server to run correctly.</p>
</section>
<section id="task-1-git-submodules">
<h3>Task 1: Git Submodules<a class="headerlink" href="#task-1-git-submodules" title="Link to this heading">¶</a></h3>
<p>Before we setup our CI job to run a Redis server, we’re going
to explore a new Git concept: submodules.</p>
<p>Your homework repository contains a simple program that connects
to a Redis server and runs a few simple commands on the Redis
server. You do not need
to understand what these commands do (we’ll discuss them in
more detail later in the homework); it is enough to know that this
program will only work if there is a Redis server running on the
same computer as the program.</p>
<p>This program depends on a library called <a class="reference external" href="https://github.com/redis/hiredis">hiredis</a>
that provides an API for C programs to send commands to a Redis server.
In fact, we need the header files from that library to compile the program.
We could, of course, install the library on our computer, but another
approach is to include the library in our repository: that way, our
repository will have everything we need to compile our program.</p>
<p>However, cloning the hiredis repository and copying it into
our repository is usually a bad idea, because it makes it harder
to track updates in the original code. For example, if hiredis releases
a new version, we would have to manually copy over their updated version
into our repository.</p>
<p>In general, the problem we’re facing is that there is some code produced
by a “third party” that we would like to include in our project. In Git,
this is typically handled by using <em>submodules</em>, which effectively allow
us to include “third party repositories” in our own repository (in other
version control systems, this is sometimes referred to as “vendor
branches”).</p>
<p>You can add submodules by using the <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">submodule</span></code> command inside your repository:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>submodule<span class="w"> </span>add<span class="w"> </span>https://github.com/redis/hiredis.git
Cloning<span class="w"> </span>into<span class="w"> </span><span class="s1">&#39;/home/studemt/2021-hw8-GITHUB_USERNAME/hiredis&#39;</span>...
remote:<span class="w"> </span>Enumerating<span class="w"> </span>objects:<span class="w"> </span><span class="m">3950</span>,<span class="w"> </span><span class="k">done</span>.
remote:<span class="w"> </span>Counting<span class="w"> </span>objects:<span class="w"> </span><span class="m">100</span>%<span class="w"> </span><span class="o">(</span><span class="m">20</span>/20<span class="o">)</span>,<span class="w"> </span><span class="k">done</span>.
remote:<span class="w"> </span>Compressing<span class="w"> </span>objects:<span class="w"> </span><span class="m">100</span>%<span class="w"> </span><span class="o">(</span><span class="m">18</span>/18<span class="o">)</span>,<span class="w"> </span><span class="k">done</span>.
remote:<span class="w"> </span>Total<span class="w"> </span><span class="m">3950</span><span class="w"> </span><span class="o">(</span>delta<span class="w"> </span><span class="m">7</span><span class="o">)</span>,<span class="w"> </span>reused<span class="w"> </span><span class="m">9</span><span class="w"> </span><span class="o">(</span>delta<span class="w"> </span><span class="m">2</span><span class="o">)</span>,<span class="w"> </span>pack-reused<span class="w"> </span><span class="m">3930</span>
Receiving<span class="w"> </span>objects:<span class="w"> </span><span class="m">100</span>%<span class="w"> </span><span class="o">(</span><span class="m">3950</span>/3950<span class="o">)</span>,<span class="w"> </span><span class="m">1</span>.34<span class="w"> </span>MiB<span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="m">14</span>.58<span class="w"> </span>MiB/s,<span class="w"> </span><span class="k">done</span>.
Resolving<span class="w"> </span>deltas:<span class="w"> </span><span class="m">100</span>%<span class="w"> </span><span class="o">(</span><span class="m">2484</span>/2484<span class="o">)</span>,<span class="w"> </span><span class="k">done</span>.
</pre></div>
</div>
<p>You’ll notice a new <code class="docutils literal notranslate"><span class="pre">hiredis</span></code> directory has appeared in your repository,
containing the files that are in the original hiredis repositories.</p>
<p>Before we continue, we need to commit this submodule. If you run
<code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">status</span></code>, you’ll see that Git is aware that we’ve added a
submodule but it has not yet been committed (besides the submodule
itself, Git has also modified a special file called <code class="docutils literal notranslate"><span class="pre">.gitmodules</span></code> that
it uses to keep track of all submodules):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>status
On<span class="w"> </span>branch<span class="w"> </span>main
Your<span class="w"> </span>branch<span class="w"> </span>is<span class="w"> </span>up<span class="w"> </span>to<span class="w"> </span>date<span class="w"> </span>with<span class="w"> </span><span class="s1">&#39;origin/main&#39;</span>.

Changes<span class="w"> </span>to<span class="w"> </span>be<span class="w"> </span>committed:
<span class="w">  </span><span class="o">(</span>use<span class="w"> </span><span class="s2">&quot;git restore --staged &lt;file&gt;...&quot;</span><span class="w"> </span>to<span class="w"> </span>unstage<span class="o">)</span>
<span class="w">        </span>new<span class="w"> </span>file:<span class="w">   </span>.gitmodules
<span class="w">        </span>new<span class="w"> </span>file:<span class="w">   </span>hiredis
</pre></div>
</div>
<p>So, simply run the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>commit<span class="w"> </span>-m<span class="s2">&quot;Added hiredis submodule&quot;</span>
$<span class="w"> </span>git<span class="w"> </span>push
</pre></div>
</div>
<p>If you go to your repo on the GitHub website, you’ll see that the
submodules are shown in a different way:</p>
<figure class="align-default">
<img alt="Submodules in GitHub" src="../_images/submodule.png" />
</figure>
<p>Git is aware that, instead of
just copying over the files into your repository, it should simply point
to other repositories.</p>
<p>Now, it will be possible for you to build hiredis, as well as the module
and the tests:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>-C<span class="w"> </span>hiredis/
$<span class="w"> </span>make<span class="w"> </span>-C<span class="w"> </span>sample/
</pre></div>
</div>
<p>However, if we try to run the sample program, it will fail because it can’t
find a Redis server to connect to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sample/sample-redis
Connection error: Connection refused
</pre></div>
</div>
<p>Before we see how to launch a Redis server as part of a CI job in the next task,
make sure you’ve successfully pushed the submodule to your GitHub
repository. You do not need to enter anything on Gradescope.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you need to clone your repository in a separate location later on,
take into account that cloning a repository does not automatically clone the
submodules in that repository, instead showing them as empty
directories. If you clone your repository somewhere else, you need to
clone it like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>--recursive<span class="w"> </span>REPO_URL
</pre></div>
</div>
<p>If you forgot to use the <code class="docutils literal notranslate"><span class="pre">--recursive</span></code> option, you can also do this
after the repository has been cloned:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>submodule<span class="w"> </span>update<span class="w"> </span>--init<span class="w"> </span>--recursive
</pre></div>
</div>
</div>
</section>
<section id="task-2-using-a-container-ized-service-in-a-github-actions-workflow">
<h3>Task 2: Using a Container-ized Service in a GitHub Actions workflow<a class="headerlink" href="#task-2-using-a-container-ized-service-in-a-github-actions-workflow" title="Link to this heading">¶</a></h3>
<p>Testing our program requires running Redis, so we will need to set up our
GitHub Actions workflow to run a Redis server. We will do
this by telling GitHub Actions to use a Docker container with Redis installed in
it. Running additional software in a Docker container is such a common operation,
that GitHub Actions makes this very easy. It basically boils down to adding
something like this to our workflow file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">:</span>
  <span class="n">redis</span><span class="p">:</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">redis</span>
    <span class="n">ports</span><span class="p">:</span>
      <span class="o">-</span> <span class="mi">6379</span><span class="p">:</span><span class="mi">6379</span>
</pre></div>
</div>
<p>That’s it! In the next task we’ll dig a bit deeper into how this translates
into specific Docker commands. For now, just add a <code class="docutils literal notranslate"><span class="pre">.github/workflows/build-and-test.yml</span></code>
file to your repository with the following contents:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="p">:</span> <span class="n">Build</span> <span class="ow">and</span> <span class="n">Test</span> <span class="n">Redis</span> <span class="n">program</span>

<span class="n">on</span><span class="p">:</span> <span class="p">[</span><span class="n">push</span><span class="p">]</span>

<span class="n">jobs</span><span class="p">:</span>
  <span class="n">build</span><span class="o">-</span><span class="ow">and</span><span class="o">-</span><span class="n">test</span><span class="p">:</span>

    <span class="n">runs</span><span class="o">-</span><span class="n">on</span><span class="p">:</span> <span class="n">ubuntu</span><span class="o">-</span><span class="n">latest</span>

    <span class="n">services</span><span class="p">:</span>
      <span class="n">redis</span><span class="o">-</span><span class="n">server</span><span class="p">:</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">redis</span>
        <span class="n">ports</span><span class="p">:</span>
          <span class="o">-</span> <span class="mi">6379</span><span class="p">:</span><span class="mi">6379</span>

    <span class="n">steps</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">uses</span><span class="p">:</span> <span class="n">actions</span><span class="o">/</span><span class="n">checkout</span><span class="nd">@v3</span>
      <span class="k">with</span><span class="p">:</span>
        <span class="n">submodules</span><span class="p">:</span> <span class="s1">&#39;recursive&#39;</span>

    <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">Build</span> <span class="n">hiredis</span>
      <span class="n">working</span><span class="o">-</span><span class="n">directory</span><span class="p">:</span> <span class="n">hiredis</span><span class="o">/</span>
      <span class="n">run</span><span class="p">:</span> <span class="o">|</span>
        <span class="n">make</span> <span class="n">clean</span>
        <span class="n">make</span>

    <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">Build</span> <span class="n">sample</span> <span class="n">program</span>
      <span class="n">working</span><span class="o">-</span><span class="n">directory</span><span class="p">:</span> <span class="n">sample</span><span class="o">/</span>
      <span class="n">run</span><span class="p">:</span> <span class="o">|</span>
        <span class="n">make</span> <span class="n">clean</span>
        <span class="n">make</span>

    <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">Run</span> <span class="n">sample</span> <span class="n">program</span>
      <span class="n">run</span><span class="p">:</span> <span class="o">./</span><span class="n">sample</span><span class="o">/</span><span class="n">sample</span><span class="o">-</span><span class="n">redis</span>
</pre></div>
</div>
<p>Go ahead and commit and push this file; this should result in a successful
workflow run. The main difference with previous workflow files we’ve
seen is the <code class="docutils literal notranslate"><span class="pre">services</span></code> option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">services</span><span class="p">:</span>
  <span class="n">redis</span><span class="o">-</span><span class="n">server</span><span class="p">:</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">redis</span>
    <span class="n">ports</span><span class="p">:</span>
      <span class="o">-</span> <span class="mi">6379</span><span class="p">:</span><span class="mi">6379</span>
</pre></div>
</div>
<p>In this option we are specifying that we want the <code class="docutils literal notranslate"><span class="pre">build-and-test</span></code> job
to run a “service” inside a Docker container for the duration of the job. The service
is named <code class="docutils literal notranslate"><span class="pre">redis-server</span></code> (we can choose any name we want here), and
we specify that the Docker container must use the <code class="docutils literal notranslate"><span class="pre">redis</span></code> container image
(you can think of the “container image” as the exact software environment
we want to run in the Docker container).</p>
<p>The value of the <code class="docutils literal notranslate"><span class="pre">image</span></code> option
has to be an image that is publicly available on <a class="reference external" href="https://hub.docker.com/">Docker Hub</a>,
a public repository of Docker images. If you browse through Docker Hub,
you’ll see that we have <em>a lot</em> of software environments at our disposal:
web servers, database servers, etc. (and all of these can be easily
launched in our workflow with the <code class="docutils literal notranslate"><span class="pre">service</span></code> option). For example,
here is the entry for the <code class="docutils literal notranslate"><span class="pre">redis</span></code> image: <a class="reference external" href="https://hub.docker.com/_/redis">https://hub.docker.com/_/redis</a></p>
<p>The <code class="docutils literal notranslate"><span class="pre">ports</span></code> option specifies how TCP ports are mapped between the Docker
container and our workflow job. You do not need to understand how TCP ports
work, but this option is required for our program to be able to connect
to the Redis server that is running in the Docker container.</p>
<p>The rest of the workflow file should be pretty self-explanatory:
we build hiredis and the sample program, and then we run the sample
program.</p>
<p>Now, fetch the URL of the workflow run, and paste it into Gradescope
(under “Task 2: Using a Container-ized Service in a GitHub Actions workflow”). Remember it will look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">uchicago</span><span class="o">-</span><span class="n">cmsc22000</span><span class="o">-</span><span class="mi">2022</span><span class="o">/</span><span class="n">hw8</span><span class="o">-</span><span class="n">GITHUB_USERNAME</span><span class="o">/</span><span class="n">actions</span><span class="o">/</span><span class="n">runs</span><span class="o">/</span><span class="n">XXXXXXXXXX</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">XXXXXXXXXX</span></code> will be a number.</p>
<p>Before continuing to the next task, take a look at the job steps in
your workflow run on GitHub: you’ll
see there is a new “Initialize containers” step, where GitHub Actions
launches a Docker container with a Redis server. The “Run sample program”
step should be able to connect to the Redis server, and you’ll see this
output in that step:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>PING:<span class="w"> </span>PONG
HSET:<span class="w"> </span><span class="o">(</span>null<span class="o">)</span>
HGET:<span class="w"> </span>Random<span class="w"> </span>J.<span class="w"> </span>Redisuser
</pre></div>
</div>
<p>If the build fails or you do not see this output, make sure to ask for
help.</p>
</section>
<section id="optional-task-3-running-docker-in-the-cs-vm">
<h3>[OPTIONAL] Task 3: Running Docker in the CS VM<a class="headerlink" href="#optional-task-3-running-docker-in-the-cs-vm" title="Link to this heading">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an optional task, and you will be able to complete
the homework even if you don’t do this task. However, even if you do not
perform the steps in this task, you should still read through the task,
as it provides some additional details on how Docker and Redis work.</p>
</div>
<p>In the previous task, we saw that GitHub Actions abstracts away all the
details of running a Docker container. In this task, we will see how
to actually run a Docker container ourselves. However, using Docker requires <a class="reference external" href="https://en.wikipedia.org/wiki/Superuser">root
privileges</a>, which you do
not have on the CS machines. So, we will use the <a class="reference external" href="https://howto.cs.uchicago.edu/vm:index">UChicago CS Virtual
Machine</a>, where you do have
the ability to run commands with root privileges.</p>
<p>Completing this task requires running the VM on your own machine,
so this task is optional and ungraded, but strongly
recommended, particularly if you’ve already installed the UChicago CS VM.</p>
<p>Once you’ve started the UChicago CS VM, open a terminal. We will first
need to install Redis and Docker on the virtual machine. You can install
Redis by running the following commands (these instructions are based on
the official Redis <a class="reference external" href="https://redis.io/download">installation
documentation</a>):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>http://download.redis.io/redis-stable.tar.gz
tar<span class="w"> </span>xzf<span class="w"> </span>redis-stable.tar.gz
<span class="nb">cd</span><span class="w"> </span>redis-stable/
make
sudo<span class="w"> </span>make<span class="w"> </span>install
</pre></div>
</div>
<p>Notice how that last command is run with <code class="docutils literal notranslate"><span class="pre">sudo</span></code>. This basically
instructs the operating system to run the command (<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code>)
with root privileges. You will be asked to enter your password which, on
the CS VM, is <code class="docutils literal notranslate"><span class="pre">uccs</span></code> by default. The reason we need to run this
command with <code class="docutils literal notranslate"><span class="pre">sudo</span></code> is because it involves installing the Redis
libraries and binaries in system-wide locations, which require root
privileges to modify.</p>
<p>Now, run the following commands (these are
based on the official Docker <a class="reference external" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">installation
documentation</a>):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>apt<span class="w"> </span>update
sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>-y<span class="w"> </span>apt-transport-https<span class="w"> </span>ca-certificates<span class="w"> </span>curl<span class="w"> </span>gnupg<span class="w"> </span>lsb-release
curl<span class="w"> </span>-fsSL<span class="w"> </span>https://download.docker.com/linux/ubuntu/gpg<span class="w"> </span><span class="p">|</span><span class="w"> </span>sudo<span class="w"> </span>gpg<span class="w"> </span>--dearmor<span class="w"> </span>-o<span class="w"> </span>/usr/share/keyrings/docker-archive-keyring.gpg
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu </span><span class="k">$(</span>lsb_release<span class="w"> </span>-cs<span class="k">)</span><span class="s2"> stable&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>sudo<span class="w"> </span>tee<span class="w"> </span>/etc/apt/sources.list.d/docker.list<span class="w"> </span>&gt;<span class="w"> </span>/dev/null
sudo<span class="w"> </span>apt-get<span class="w"> </span>update
sudo<span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>-y<span class="w"> </span>docker-ce<span class="w"> </span>docker-ce-cli<span class="w"> </span>containerd.io
</pre></div>
</div>
<p>You can verify that Docker is correctly installed by running this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>hello-world
</pre></div>
</div>
<p>This will run a container whose sole purpose is to print out a welcome
message. If you do not see a message that starts with “Hello from
Docker!”, please ask for help.</p>
<p>We can run a Redis container simply by running the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>--name<span class="w"> </span>redis-server<span class="w"> </span>-p<span class="w"> </span><span class="m">6379</span>:6379<span class="w"> </span>redis
</pre></div>
</div>
<p>Docker will first download the Redis container image from <a class="reference external" href="https://hub.docker.com/_/redis/">Docker
Hub</a>, and then run it. You should
see some output that ends with something like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="m">1</span>:M<span class="w"> </span><span class="m">11</span><span class="w"> </span>May<span class="w"> </span><span class="m">2021</span><span class="w"> </span><span class="m">14</span>:16:09.584<span class="w"> </span>*<span class="w"> </span>Ready<span class="w"> </span>to<span class="w"> </span>accept<span class="w"> </span>connections
</pre></div>
</div>
<p>Now, open another terminal in the VM and run this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>redis-cli
</pre></div>
</div>
<p>This should open up a prompt like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="m">127</span>.0.0.1:6379&gt;
</pre></div>
</div>
<p>This means that the Redis CLI tool running on your VM has successfully
connected to the Redis server running inside the Docker container.
However, notice how we’re not running Redis directly on the VM (we
installed Redis so we could use the <code class="docutils literal notranslate"><span class="pre">redis-cli</span></code> tool, but we never ran
the <code class="docutils literal notranslate"><span class="pre">redis-server</span></code> command on the VM).</p>
<p>You can now try running a few Redis commands from the Redis CLI:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="m">127</span>.0.0.1:6379&gt;<span class="w"> </span>SET<span class="w"> </span>foo<span class="w"> </span><span class="m">42</span>
OK
<span class="m">127</span>.0.0.1:6379&gt;<span class="w"> </span>GET<span class="w"> </span>foo
<span class="s2">&quot;42&quot;</span>
<span class="m">127</span>.0.0.1:6379&gt;<span class="w"> </span>HSET<span class="w"> </span>myhash<span class="w"> </span>name<span class="w"> </span><span class="s2">&quot;Borja&quot;</span>
<span class="o">(</span>integer<span class="o">)</span><span class="w"> </span><span class="m">1</span>
<span class="m">127</span>.0.0.1:6379&gt;<span class="w"> </span>HGET<span class="w"> </span>myhash<span class="w"> </span>name
<span class="s2">&quot;Borja&quot;</span>
<span class="m">127</span>.0.0.1:6379&gt;<span class="w"> </span>HSET<span class="w"> </span>myhash<span class="w"> </span>email<span class="w"> </span><span class="s2">&quot;borja@cs.uchicago.edu&quot;</span>
<span class="o">(</span>integer<span class="o">)</span><span class="w"> </span><span class="m">1</span>
<span class="m">127</span>.0.0.1:6379&gt;<span class="w"> </span>HKEYS<span class="w"> </span>myhash
<span class="m">1</span><span class="o">)</span><span class="w"> </span><span class="s2">&quot;name&quot;</span>
<span class="m">2</span><span class="o">)</span><span class="w"> </span><span class="s2">&quot;email&quot;</span>
</pre></div>
</div>
<p>The above commands basically set and get the value of a variable called
<code class="docutils literal notranslate"><span class="pre">foo</span></code> (using the <code class="docutils literal notranslate"><span class="pre">SET</span></code> and <code class="docutils literal notranslate"><span class="pre">GET</span></code>) commands, and also create a
hash table called <code class="docutils literal notranslate"><span class="pre">myhash</span></code> where we set values for two keys, <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">email</span></code>,
using the <code class="docutils literal notranslate"><span class="pre">HSET</span></code> command. We can then get values from the hash table using
the <code class="docutils literal notranslate"><span class="pre">HGET</span></code> command, or list all the keys in the hash table using the <code class="docutils literal notranslate"><span class="pre">HKEYS</span></code> command.</p>
<p>On a separate terminal, you can also try running a few Docker commands:</p>
<ul class="simple">
<li><p>To see the list of container images: <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">image</span> <span class="pre">list</span></code></p></li>
<li><p>To see the list of running containers: <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">container</span> <span class="pre">list</span></code></p></li>
<li><p>To stop the Redis container:
<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">container</span> <span class="pre">stop</span> <span class="pre">redis-server</span></code></p></li>
<li><p>To start the Redis container again:
<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">container</span> <span class="pre">start</span> <span class="pre">-a</span> <span class="pre">redis-server</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before continuing with the rest of the task, make sure to stop
the Docker container you’ve just launched. Otherwise, it will
interfere with the rest of the task.</p>
</div>
<p>So far, we’ve been using pre-existing container images found on <a class="reference external" href="https://hub.docker.com/_/redis/">Docker
Hub</a>, but we also have the ability
to define our own container images. Your homework repository includes
a <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> file that includes the specification of a custom Redis
image.</p>
<p>To give it a try, we’ll clone our “starter code” repository for this
homework. This repository contains the same files that were added
to your homework repository, and will be more straightforward to
clone, since it is a public repository (you can also clone your
homework repository, but you would need to either create SSH
keys inside the VM, and upload them to GitHub, or obtain a
Personal Access Token from GitHub).</p>
<p>So, let’s run the following (if you are still inside the <cite>redis-stable</cite> directory, make sure to <cite>cd</cite>
back to your home directory before running the following command):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/uchicago-cmsc22000/hw8-starter-code.git
</pre></div>
</div>
<p>Then, go into the repository directory:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>hw8-starter-code
</pre></div>
</div>
<p>Now, take a look at the <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> file. This file instructs Docker
on how to build a new container image. The first line
tells Docker to use the <code class="docutils literal notranslate"><span class="pre">gcc</span></code> image on Docker Hub as a starting
point (since we’re building Redis from scratch, we need access to
a software environment with a compiler):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">gcc</span><span class="p">:</span><span class="mf">9.3</span>
</pre></div>
</div>
<p>The next lines are essentially the same commands we ran earlier
to build Redis in the VM:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Download Redis</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">tmp</span>
<span class="n">RUN</span> <span class="n">wget</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">download</span><span class="o">.</span><span class="n">redis</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="n">stable</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
<span class="n">RUN</span> <span class="n">tar</span> <span class="n">xzf</span> <span class="n">redis</span><span class="o">-</span><span class="n">stable</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>

<span class="c1"># Build and install Redis</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="n">stable</span><span class="o">/</span>
<span class="n">RUN</span> <span class="n">make</span>
<span class="n">RUN</span> <span class="n">make</span> <span class="n">install</span>

<span class="c1"># Clean up</span>
<span class="n">RUN</span> <span class="n">rm</span> <span class="o">-</span><span class="n">rf</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="n">stable</span><span class="o">/</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">redis</span><span class="o">-</span><span class="n">stable</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
</pre></div>
</div>
<p>Finally, we need to specify the command that will be run
whenever we launch a container with this image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Command to run when container is launched</span>
<span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;redis-server&quot;</span><span class="p">,</span> <span class="s2">&quot;--protected-mode&quot;</span><span class="p">,</span> <span class="s2">&quot;no&quot;</span><span class="p">,</span> <span class="s2">&quot;--bind&quot;</span><span class="p">,</span> <span class="s2">&quot;0.0.0.0&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>To be clear, the <code class="docutils literal notranslate"><span class="pre">RUN</span></code> commands are run only once, when the container
image is first built, not every time we launch the container.</p>
<p>To build our custom container, run this command:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>custom-redis<span class="w"> </span>.
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">.</span></code> refers to the current directory (which contains the <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>
that Docker needs to build the container image).</p>
<p>This may take a while, as Docker has to download a number of other
container images to build ours <em>and</em> it has to build Redis from
scratch. Once it finishes building the image, you can run the container like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>-p<span class="w"> </span><span class="m">6379</span>:6379<span class="w"> </span>custom-redis
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you get a <code class="docutils literal notranslate"><span class="pre">port</span> <span class="pre">is</span> <span class="pre">already</span> <span class="pre">allocated</span></code> error, make sure the container
you launched previously has been stopped:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">container</span> <span class="n">stop</span> <span class="n">redis</span><span class="o">-</span><span class="n">server</span>
</pre></div>
</div>
</div>
<p>Before proceeding, let’s make sure to add the hiredis submodule (yes,
you did this earlier in the homework, but in your own repository;
it is not a part of the “starter code” repository). In a separate
terminal, run this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>submodule<span class="w"> </span>add<span class="w"> </span>https://github.com/redis/hiredis.git
</pre></div>
</div>
<p>Now, build hiredis and the sample program:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>-C<span class="w"> </span>hiredis/
$<span class="w"> </span>make<span class="w"> </span>-C<span class="w"> </span>sample/
</pre></div>
</div>
<p>You should now be able to run the test program:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./sample/sample-redis
PING:<span class="w"> </span>PONG
HSET:<span class="w"> </span><span class="o">(</span>null<span class="o">)</span>
HGET:<span class="w"> </span>Random<span class="w"> </span>J.<span class="w"> </span>Redisuser
</pre></div>
</div>
</section>
<section id="task-4-using-a-custom-dockerfile-in-our-workflow">
<h3>Task 4: Using a Custom Dockerfile in our Workflow<a class="headerlink" href="#task-4-using-a-custom-dockerfile-in-our-workflow" title="Link to this heading">¶</a></h3>
<p>Now that we’ve seen how to specify a custom container, let’s try using it
in our CI workflow. Please note that you don’t need to complete this
task on the CS VM. You can follow all the necessary steps while logged
into a CS machine.</p>
<p>Update the <code class="docutils literal notranslate"><span class="pre">.github/workflows/build-and-test.yml</span></code> file in your repository so
it will contain the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="p">:</span> <span class="n">Build</span> <span class="ow">and</span> <span class="n">Test</span> <span class="n">Redis</span> <span class="n">program</span>

<span class="n">on</span><span class="p">:</span> <span class="p">[</span><span class="n">push</span><span class="p">]</span>

<span class="n">jobs</span><span class="p">:</span>
  <span class="n">build</span><span class="o">-</span><span class="ow">and</span><span class="o">-</span><span class="n">test</span><span class="p">:</span>

    <span class="n">runs</span><span class="o">-</span><span class="n">on</span><span class="p">:</span> <span class="n">ubuntu</span><span class="o">-</span><span class="n">latest</span>

    <span class="n">steps</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">uses</span><span class="p">:</span> <span class="n">actions</span><span class="o">/</span><span class="n">checkout</span><span class="nd">@v3</span>
      <span class="k">with</span><span class="p">:</span>
        <span class="n">submodules</span><span class="p">:</span> <span class="s1">&#39;recursive&#39;</span>

    <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">Build</span> <span class="ow">and</span> <span class="n">run</span> <span class="n">Docker</span> <span class="n">container</span>
      <span class="n">run</span><span class="p">:</span> <span class="o">|</span>
        <span class="n">sudo</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">custom</span><span class="o">-</span><span class="n">redis</span> <span class="o">.</span>
        <span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">p</span> <span class="mi">6379</span><span class="p">:</span><span class="mi">6379</span> <span class="n">custom</span><span class="o">-</span><span class="n">redis</span>
        <span class="n">sudo</span> <span class="n">docker</span> <span class="n">container</span> <span class="nb">list</span>

    <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">Build</span> <span class="n">hiredis</span>
      <span class="n">working</span><span class="o">-</span><span class="n">directory</span><span class="p">:</span> <span class="n">hiredis</span><span class="o">/</span>
      <span class="n">run</span><span class="p">:</span> <span class="o">|</span>
        <span class="n">make</span> <span class="n">clean</span>
        <span class="n">make</span>

    <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">Build</span> <span class="n">sample</span> <span class="n">program</span>
      <span class="n">working</span><span class="o">-</span><span class="n">directory</span><span class="p">:</span> <span class="n">sample</span><span class="o">/</span>
      <span class="n">run</span><span class="p">:</span> <span class="o">|</span>
        <span class="n">make</span> <span class="n">clean</span>
        <span class="n">make</span>

    <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">Run</span> <span class="n">sample</span> <span class="n">program</span>
      <span class="n">run</span><span class="p">:</span> <span class="o">./</span><span class="n">sample</span><span class="o">/</span><span class="n">sample</span><span class="o">-</span><span class="n">redis</span>
</pre></div>
</div>
<p>Notice how we’ve removed the <code class="docutils literal notranslate"><span class="pre">services</span></code> option, and instead added a new
step that manually builds and runs our custom container. We’ve also included
<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">list</span></code> to double-check that our container is running.</p>
<p>You’ll notice that this workflow takes considerably longer to run than previous
workflow, because building the custom container involves building Redis from
scratch. In practice, we would not build this container from scratch in
every workflow run and, instead, we would either upload our container image
to Docker Hub so we can easily reuse it, or we would make use of GitHub Actions’
<a class="reference external" href="https://docs.github.com/en/actions/guides/caching-dependencies-to-speed-up-workflows">caching features</a>
to reuse the container image across multiple workflow runs.</p>
<p>Before continuing, take the URL of your successful workflow run, and paste it into Gradescope
(under “Task 4: Using a Custom Dockerfile in our Workflow”).</p>
</section>
</section>
<section id="part-ii-a-complete-deployment-pipeline">
<h2>Part II: A Complete Deployment Pipeline<a class="headerlink" href="#part-ii-a-complete-deployment-pipeline" title="Link to this heading">¶</a></h2>
<p>In class, we have discussed that software is rarely deployed directly
into production but, instead, follows a <em>deployment pipeline</em>. In our
previous homework we saw a very basic deployment pipeline: we set up our
HelloApp to deploy to Heroku, but only if the CI tests passed. In this
homework, we are going to see a more complete deployment pipeline.</p>
<p>As we saw in the deployment lecture, a common pipeline is as follows:</p>
<ul class="simple">
<li><p><em>Local</em>, where you are the only one making changes to your codebase.</p></li>
<li><p><em>Staging</em>, where all developers can see your changes, but you have
time to catch errors before showing the end-users.</p></li>
<li><p><em>Production</em>, where your app is available to the real world. Usually,
the staging app will be promoted to production when it is ready.</p></li>
</ul>
<p>In this homework, you’ll create a more complete Heroku pipeline for last
week’s HelloApp. Please note that you will not be answering question
on Gradescope for each of the tasks; instead, you will have to provide
two URLs for this entire part of the homework (we will tell you which
URLs when we get to them)</p>
<p>If you did not successfully complete Homework #7, please ask
for help so we can ensure that you’re all set up for this week’s homework.</p>
<p>Heroku already provides support for creating pipelines, and ours will
have three stages:</p>
<ul class="simple">
<li><p><em>Review</em>: Similar to a development stage. In Heroku, we can
automatically link this stage to our pull requests on GitHub, so we
can easily test any changes we are proposing in a pull request.</p></li>
<li><p><em>Staging</em>: We will be using the app you created in Homework #7 as our
staging app.</p></li>
<li><p><em>Production</em>: A new production app that is only available if we are
satisfied with our staging app.</p></li>
</ul>
<section id="task-1-create-a-pipeline">
<h3>Task 1: Create a Pipeline<a class="headerlink" href="#task-1-create-a-pipeline" title="Link to this heading">¶</a></h3>
<p>In this task, you’ll create a new Heroku Pipeline, using the
<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-hw7</span></code> app (from last week’s homework) as the staging
app. Note that a common convention is for staging apps
to have <code class="docutils literal notranslate"><span class="pre">-staging</span></code> as a suffix, but it won’t be necessary for you to
rename your app in this homework.</p>
<p>On Gradescope, enter the URL of the HelloApp you deployed in Homework #7.
While you will be adding it to a deployment pipeline, its URL will
remain the same in this homework.</p>
<p>To create the pipeline, log into Heroku, and select the app you created
in Homework #7. Under the Deploy tab, click on “Choose a pipeline” (in the
“Add this app to a pipeline” section) and then “Create new pipeline”.
Name your pipeline <code class="docutils literal notranslate"><span class="pre">CNETID-pipeline</span></code> (where <code class="docutils literal notranslate"><span class="pre">CNETID</span></code> should be
replaced with your CNetID). You will also be asked to specify “Choose a
stage to add this app to”. Make sure that “staging” is selected.
Finally, click on “Create pipeline”.</p>
<p>You will now be shown the pipeline’s configuration (you will also be
able to access this page through your dashboard, which will now include
a <code class="docutils literal notranslate"><span class="pre">CNETID-pipeline</span></code> pipeline). Notice how there is no production
app in your pipeline. In the real world, this would mean that
your end users don’t see anything!</p>
</section>
<section id="task-2-add-a-production-app">
<h3>Task 2: Add a production app<a class="headerlink" href="#task-2-add-a-production-app" title="Link to this heading">¶</a></h3>
<p>In this task, you’ll add a production app to your pipeline.
Unlike the app in staging, your production app won’t be associated with
any specific repo. Instead, once your staging app is good to go,
you can <em>promote</em> it to be the production app. That means the
production app will just take the staging app, make a copy of
it, and run that copy as the production app. This means that, if you
make changes to the staging app, those changes won’t appear in
production until you explicitly promote the staging app to production
again.</p>
<p>Later in the homework you may see Heroku messages that talk about “slugs”; in
Heroku parlance, a “slug” is a pre-compiled version of your app that is
ready to run. So, when we promote to production, we don’t actually
rebuild the application; we just take the “slug” that is in staging, and
copy it to production.</p>
<p>To add a production application, all you have to do is go to your
pipeline and, under “Production”, click on “Add app” and then “Create
new app”. Name the application <code class="docutils literal notranslate"><span class="pre">CNETID-cs220-prod</span></code> (where <code class="docutils literal notranslate"><span class="pre">CNETID</span></code>
should be replaced with your CNetID). Notice how, if you try to access
your app on Heroku (just go to <a class="reference external" href="http://CNETID-cs220-prod.herokuapp.com/">http://CNETID-cs220-prod.herokuapp.com/</a>),
you’ll just see a placeholder page, not HelloApp. That’s because we
haven’t promoted our staging app to production yet.</p>
<p>On Gradescope, enter the URL of the production HelloApp you just created
(don’t worry about the fact that it’s just showing a placeholder page;
we will change this in the following task, and the URL of your app
will remain the same).</p>
</section>
<section id="task-3-promoting-from-staging-to-production">
<h3>Task 3: Promoting from staging to production<a class="headerlink" href="#task-3-promoting-from-staging-to-production" title="Link to this heading">¶</a></h3>
<p>First, let’s make a change to our HelloApp: it’s time to upgrade to
HelloApp 2.0!</p>
<ul class="simple">
<li><p>In your repository from Homework #7 (<code class="docutils literal notranslate"><span class="pre">hw7-GITHUB_USERNAME</span></code>), edit
<code class="docutils literal notranslate"><span class="pre">hello/templates/base.html</span></code> and change <code class="docutils literal notranslate"><span class="pre">&lt;h1&gt;HelloApp&lt;/h1&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">&lt;h1&gt;HelloApp</span> <span class="pre">2.0&lt;/h1&gt;</span></code></p></li>
<li><p>Remember that, at the end of Homework #7, we actually left the app
in a broken state (it would not pass the tests). Double-check that
line 10 in file <code class="docutils literal notranslate"><span class="pre">hello/templates/index.html</span></code> is <code class="docutils literal notranslate"><span class="pre">Hello,</span> <span class="pre">{{name}}!</span></code>
(otherwise, the tests will fail).</p></li>
<li><p>Commit and push this change with the message “Update to 2.0”</p></li>
<li><p>Assuming you completed Homework #7 last week, your updated app will
automatically deploy (you can check the status of the deployment
by looking at the latest workflow run on the repository’s Actions tab)</p></li>
</ul>
<p>Now, notice that if you navigate to your staging website
(<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-hw7.herokuapp.com</span></code>) you’ll see your change. But if you
navigate to your production website
(<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-prod.herokuapp.com</span></code>), you’ll still see a placeholder
page.</p>
<p>Why is this? Changes from staging are <em>not</em> automatically deployed to
production. This is intentional: we often don’t want things to
automatically deploy to production, since we might risk breaking the
public-facing version of our app. Pushing code that is broken is known
as “breaking the build”, and you absolutely don’t want that to propagate
to production (by the way, if you know anyone who has done a software
development internship or works in software development, ask them if
they’ve ever “broken the build”; we guarantee you’ll hear some
entertaining stories). By having a pipeline, we can ensure that users
continuously see our production app, without mistakes, and we only update it
when we’re absolutely sure.</p>
<p>So, let’s go ahead and promote our staging application to production.
You can do this simply by pressing the “Promote to production…” button
in the staging app of your pipeline. Once you do this, your staging app
(<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-hw7.herokuapp.com</span></code>) and your production app
(<code class="docutils literal notranslate"><span class="pre">CNETID-cs220-prod.herokuapp.com</span></code>) should look exactly the same.</p>
</section>
<section id="addendum-review-apps">
<h3>Addendum: Review Apps<a class="headerlink" href="#addendum-review-apps" title="Link to this heading">¶</a></h3>
<p>Currently, in order to make changes to staging, you have to directly
modify the main branch of your repo. Can you imagine why this is a bad
idea?</p>
<p>In order to show your changes to anyone, you’d have to directly change
staging, which isn’t as bad as directly modifying production, but could
be embarrassing if you’re trying to get a small change approved and then
break everything for every other developer in your team!</p>
<p>One way of addressing this is by adding a <em>review app</em> stage to the
pipeline, which results in a new app being deployed for each
new pull request submitted to GitHub.
This lets developers see what the app would look like if the pull
request were merged.</p>
<p>Unfortunately, while Heroku does support this feature, it is
(as of May 2022) currently disabled because of a security incident
between GitHub and Heroku, which resulted in certain integrations
between GitHub and Heroku being disabled.</p>
<p>So, you will not be able to create a review app. All you need
to know is that this is an additional stage we could potentially
add to make it easier to review changes to an app before
they’re merged to the main branch.</p>
</section>
</section>
<section id="submitting-your-homework">
<h2>Submitting your homework<a class="headerlink" href="#submitting-your-homework" title="Link to this heading">¶</a></h2>
<p>In this homework, you just need to enter a few URLs into Gradescope (make
sure you’ve done so at the points instructed above). You should also
make sure you’ve pushed your code to GitHub, as we need to check
whether you created the <code class="docutils literal notranslate"><span class="pre">hiredis</span></code> submodule correctly
(however, you will not be submitting your code through Gradescope).</p>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2011-2021, The University of Chicago.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.2.6.<br/>
    </p>
  </div>
</footer>
  </body>
</html>